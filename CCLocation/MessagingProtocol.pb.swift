// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: MessagingProtocol.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///upgrade to proto3

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Top level wrapper for message from Server to Device
struct Messaging_ServerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var globalSettings: Messaging_GlobalSettings {
    get {return _storage._globalSettings ?? Messaging_GlobalSettings()}
    set {_uniqueStorage()._globalSettings = newValue}
  }
  /// Returns true if `globalSettings` has been explicitly set.
  var hasGlobalSettings: Bool {return _storage._globalSettings != nil}
  /// Clears the value of `globalSettings`. Subsequent reads from it will return its default value.
  mutating func clearGlobalSettings() {_uniqueStorage()._globalSettings = nil}

  var iosSettings: Messaging_IosSettings {
    get {return _storage._iosSettings ?? Messaging_IosSettings()}
    set {_uniqueStorage()._iosSettings = newValue}
  }
  /// Returns true if `iosSettings` has been explicitly set.
  var hasIosSettings: Bool {return _storage._iosSettings != nil}
  /// Clears the value of `iosSettings`. Subsequent reads from it will return its default value.
  mutating func clearIosSettings() {_uniqueStorage()._iosSettings = nil}

  var androidSettings: Messaging_AndroidSettings {
    get {return _storage._androidSettings ?? Messaging_AndroidSettings()}
    set {_uniqueStorage()._androidSettings = newValue}
  }
  /// Returns true if `androidSettings` has been explicitly set.
  var hasAndroidSettings: Bool {return _storage._androidSettings != nil}
  /// Clears the value of `androidSettings`. Subsequent reads from it will return its default value.
  mutating func clearAndroidSettings() {_uniqueStorage()._androidSettings = nil}

  ///for server use only
  var clientKey: String {
    get {return _storage._clientKey ?? String()}
    set {_uniqueStorage()._clientKey = newValue}
  }
  /// Returns true if `clientKey` has been explicitly set.
  var hasClientKey: Bool {return _storage._clientKey != nil}
  /// Clears the value of `clientKey`. Subsequent reads from it will return its default value.
  mutating func clearClientKey() {_uniqueStorage()._clientKey = nil}

  ///for server use only
  var deviceID: Data {
    get {return _storage._deviceID ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  var hasDeviceID: Bool {return _storage._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  mutating func clearDeviceID() {_uniqueStorage()._deviceID = nil}

  ///for server use only
  var sentTimestamp: UInt64 {
    get {return _storage._sentTimestamp ?? 0}
    set {_uniqueStorage()._sentTimestamp = newValue}
  }
  /// Returns true if `sentTimestamp` has been explicitly set.
  var hasSentTimestamp: Bool {return _storage._sentTimestamp != nil}
  /// Clears the value of `sentTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearSentTimestamp() {_uniqueStorage()._sentTimestamp = nil}

  var messageIdentifier: Data {
    get {return _storage._messageIdentifier ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._messageIdentifier = newValue}
  }
  /// Returns true if `messageIdentifier` has been explicitly set.
  var hasMessageIdentifier: Bool {return _storage._messageIdentifier != nil}
  /// Clears the value of `messageIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearMessageIdentifier() {_uniqueStorage()._messageIdentifier = nil}

  var stop: Messaging_ServerMessage.StopType {
    get {return _storage._stop ?? .stop}
    set {_uniqueStorage()._stop = newValue}
  }
  /// Returns true if `stop` has been explicitly set.
  var hasStop: Bool {return _storage._stop != nil}
  /// Clears the value of `stop`. Subsequent reads from it will return its default value.
  mutating func clearStop() {_uniqueStorage()._stop = nil}

  var locationResponses: [Messaging_ClientLocationResponse] {
    get {return _storage._locationResponses}
    set {_uniqueStorage()._locationResponses = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StopType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case stop // = 1
    case terminate // = 2

    init() {
      self = .stop
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .stop
      case 2: self = .terminate
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .stop: return 1
      case .terminate: return 2
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Messaging_ServerMessage.StopType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///Top level wrapper for iOS specific messages
struct Messaging_IosSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var geoSettings: Messaging_IosGeoSettings {
    get {return _storage._geoSettings ?? Messaging_IosGeoSettings()}
    set {_uniqueStorage()._geoSettings = newValue}
  }
  /// Returns true if `geoSettings` has been explicitly set.
  var hasGeoSettings: Bool {return _storage._geoSettings != nil}
  /// Clears the value of `geoSettings`. Subsequent reads from it will return its default value.
  mutating func clearGeoSettings() {_uniqueStorage()._geoSettings = nil}

  var beaconSettings: Messaging_IosBeaconSettings {
    get {return _storage._beaconSettings ?? Messaging_IosBeaconSettings()}
    set {_uniqueStorage()._beaconSettings = newValue}
  }
  /// Returns true if `beaconSettings` has been explicitly set.
  var hasBeaconSettings: Bool {return _storage._beaconSettings != nil}
  /// Clears the value of `beaconSettings`. Subsequent reads from it will return its default value.
  mutating func clearBeaconSettings() {_uniqueStorage()._beaconSettings = nil}

  ///Time in milliseconds to extend background operation
  var backgroundExtension: UInt64 {
    get {return _storage._backgroundExtension ?? 0}
    set {_uniqueStorage()._backgroundExtension = newValue}
  }
  /// Returns true if `backgroundExtension` has been explicitly set.
  var hasBackgroundExtension: Bool {return _storage._backgroundExtension != nil}
  /// Clears the value of `backgroundExtension`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundExtension() {_uniqueStorage()._backgroundExtension = nil}

  var inertialSettings: Messaging_IosInertialSettings {
    get {return _storage._inertialSettings ?? Messaging_IosInertialSettings()}
    set {_uniqueStorage()._inertialSettings = newValue}
  }
  /// Returns true if `inertialSettings` has been explicitly set.
  var hasInertialSettings: Bool {return _storage._inertialSettings != nil}
  /// Clears the value of `inertialSettings`. Subsequent reads from it will return its default value.
  mutating func clearInertialSettings() {_uniqueStorage()._inertialSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Messaging_IosBeaconSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///regions to monitor for
  var monitoring: Messaging_BeaconMonitoring {
    get {return _storage._monitoring ?? Messaging_BeaconMonitoring()}
    set {_uniqueStorage()._monitoring = newValue}
  }
  /// Returns true if `monitoring` has been explicitly set.
  var hasMonitoring: Bool {return _storage._monitoring != nil}
  /// Clears the value of `monitoring`. Subsequent reads from it will return its default value.
  mutating func clearMonitoring() {_uniqueStorage()._monitoring = nil}

  ///ranging to be used when app has focus
  var foregroundRanging: Messaging_BeaconRanging {
    get {return _storage._foregroundRanging ?? Messaging_BeaconRanging()}
    set {_uniqueStorage()._foregroundRanging = newValue}
  }
  /// Returns true if `foregroundRanging` has been explicitly set.
  var hasForegroundRanging: Bool {return _storage._foregroundRanging != nil}
  /// Clears the value of `foregroundRanging`. Subsequent reads from it will return its default value.
  mutating func clearForegroundRanging() {_uniqueStorage()._foregroundRanging = nil}

  ///ranging to be used when app is in background
  var backgroundRanging: Messaging_BeaconRanging {
    get {return _storage._backgroundRanging ?? Messaging_BeaconRanging()}
    set {_uniqueStorage()._backgroundRanging = newValue}
  }
  /// Returns true if `backgroundRanging` has been explicitly set.
  var hasBackgroundRanging: Bool {return _storage._backgroundRanging != nil}
  /// Clears the value of `backgroundRanging`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundRanging() {_uniqueStorage()._backgroundRanging = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///iOS Geo Settings
struct Messaging_IosStandardGeoSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The max time in milliseconds to activate updates. If the app is still running after this time, stop updates.
  var maxRunTime: UInt64 {
    get {return _maxRunTime ?? 0}
    set {_maxRunTime = newValue}
  }
  /// Returns true if `maxRunTime` has been explicitly set.
  var hasMaxRunTime: Bool {return self._maxRunTime != nil}
  /// Clears the value of `maxRunTime`. Subsequent reads from it will return its default value.
  mutating func clearMaxRunTime() {self._maxRunTime = nil}

  ///minimum off period - must work across multiple wake up / kills. Don't start updates again until at least this time has elapsed.
  var minOffTime: UInt64 {
    get {return _minOffTime ?? 0}
    set {_minOffTime = newValue}
  }
  /// Returns true if `minOffTime` has been explicitly set.
  var hasMinOffTime: Bool {return self._minOffTime != nil}
  /// Clears the value of `minOffTime`. Subsequent reads from it will return its default value.
  mutating func clearMinOffTime() {self._minOffTime = nil}

  /// Integer required accuracy
  var desiredAccuracy: Int32 {
    get {return _desiredAccuracy ?? 0}
    set {_desiredAccuracy = newValue}
  }
  /// Returns true if `desiredAccuracy` has been explicitly set.
  var hasDesiredAccuracy: Bool {return self._desiredAccuracy != nil}
  /// Clears the value of `desiredAccuracy`. Subsequent reads from it will return its default value.
  mutating func clearDesiredAccuracy() {self._desiredAccuracy = nil}

  /// Integer min distance filter
  var distanceFilter: Int32 {
    get {return _distanceFilter ?? 0}
    set {_distanceFilter = newValue}
  }
  /// Returns true if `distanceFilter` has been explicitly set.
  var hasDistanceFilter: Bool {return self._distanceFilter != nil}
  /// Clears the value of `distanceFilter`. Subsequent reads from it will return its default value.
  mutating func clearDistanceFilter() {self._distanceFilter = nil}

  /// Pause updates automatically flag
  var pausesUpdates: Bool {
    get {return _pausesUpdates ?? false}
    set {_pausesUpdates = newValue}
  }
  /// Returns true if `pausesUpdates` has been explicitly set.
  var hasPausesUpdates: Bool {return self._pausesUpdates != nil}
  /// Clears the value of `pausesUpdates`. Subsequent reads from it will return its default value.
  mutating func clearPausesUpdates() {self._pausesUpdates = nil}

  /// One of the four activity types
  var activityType: Messaging_IosStandardGeoSettings.Activity {
    get {return _activityType ?? .other}
    set {_activityType = newValue}
  }
  /// Returns true if `activityType` has been explicitly set.
  var hasActivityType: Bool {return self._activityType != nil}
  /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
  mutating func clearActivityType() {self._activityType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Activity: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case other // = 0
    case auto // = 1
    case fitness // = 2
    case navigation // = 3

    init() {
      self = .other
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .other
      case 1: self = .auto
      case 2: self = .fitness
      case 3: self = .navigation
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .other: return 0
      case .auto: return 1
      case .fitness: return 2
      case .navigation: return 3
      }
    }

  }

  init() {}

  fileprivate var _maxRunTime: UInt64? = nil
  fileprivate var _minOffTime: UInt64? = nil
  fileprivate var _desiredAccuracy: Int32? = nil
  fileprivate var _distanceFilter: Int32? = nil
  fileprivate var _pausesUpdates: Bool? = nil
  fileprivate var _activityType: Messaging_IosStandardGeoSettings.Activity? = nil
}

#if swift(>=4.2)

extension Messaging_IosStandardGeoSettings.Activity: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Messaging_IosGeoSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///if true enable significant updates permanently. Otherwise switch off
  var significantUpates: Bool {
    get {return _storage._significantUpates ?? false}
    set {_uniqueStorage()._significantUpates = newValue}
  }
  /// Returns true if `significantUpates` has been explicitly set.
  var hasSignificantUpates: Bool {return _storage._significantUpates != nil}
  /// Clears the value of `significantUpates`. Subsequent reads from it will return its default value.
  mutating func clearSignificantUpates() {_uniqueStorage()._significantUpates = nil}

  ///if present, use these standard settings while the app has user focus
  var foregroundGeo: Messaging_IosStandardGeoSettings {
    get {return _storage._foregroundGeo ?? Messaging_IosStandardGeoSettings()}
    set {_uniqueStorage()._foregroundGeo = newValue}
  }
  /// Returns true if `foregroundGeo` has been explicitly set.
  var hasForegroundGeo: Bool {return _storage._foregroundGeo != nil}
  /// Clears the value of `foregroundGeo`. Subsequent reads from it will return its default value.
  mutating func clearForegroundGeo() {_uniqueStorage()._foregroundGeo = nil}

  ///if present, use these standard settings while the app is running in background
  var backgroundGeo: Messaging_IosStandardGeoSettings {
    get {return _storage._backgroundGeo ?? Messaging_IosStandardGeoSettings()}
    set {_uniqueStorage()._backgroundGeo = newValue}
  }
  /// Returns true if `backgroundGeo` has been explicitly set.
  var hasBackgroundGeo: Bool {return _storage._backgroundGeo != nil}
  /// Clears the value of `backgroundGeo`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundGeo() {_uniqueStorage()._backgroundGeo = nil}

  var iosCircularGeoFences: [Messaging_IosCircularGeoFence] {
    get {return _storage._iosCircularGeoFences}
    set {_uniqueStorage()._iosCircularGeoFences = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Messaging_IosCircularGeoFence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var radius: Double {
    get {return _radius ?? 0}
    set {_radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return self._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {self._radius = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _radius: Double? = nil
}

struct Messaging_IosInertialSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {self._enabled = nil}

  var interval: UInt32 {
    get {return _interval ?? 0}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  mutating func clearInterval() {self._interval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enabled: Bool? = nil
  fileprivate var _interval: UInt32? = nil
}

///Top level wrapper for Android specific messages
struct Messaging_AndroidSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var geoSettings: Messaging_AndroidGeoSettings {
    get {return _storage._geoSettings ?? Messaging_AndroidGeoSettings()}
    set {_uniqueStorage()._geoSettings = newValue}
  }
  /// Returns true if `geoSettings` has been explicitly set.
  var hasGeoSettings: Bool {return _storage._geoSettings != nil}
  /// Clears the value of `geoSettings`. Subsequent reads from it will return its default value.
  mutating func clearGeoSettings() {_uniqueStorage()._geoSettings = nil}

  var beaconSettings: Messaging_AndroidBeaconSettings {
    get {return _storage._beaconSettings ?? Messaging_AndroidBeaconSettings()}
    set {_uniqueStorage()._beaconSettings = newValue}
  }
  /// Returns true if `beaconSettings` has been explicitly set.
  var hasBeaconSettings: Bool {return _storage._beaconSettings != nil}
  /// Clears the value of `beaconSettings`. Subsequent reads from it will return its default value.
  mutating func clearBeaconSettings() {_uniqueStorage()._beaconSettings = nil}

  var wifiSettings: Messaging_AndroidWifiSettings {
    get {return _storage._wifiSettings ?? Messaging_AndroidWifiSettings()}
    set {_uniqueStorage()._wifiSettings = newValue}
  }
  /// Returns true if `wifiSettings` has been explicitly set.
  var hasWifiSettings: Bool {return _storage._wifiSettings != nil}
  /// Clears the value of `wifiSettings`. Subsequent reads from it will return its default value.
  mutating func clearWifiSettings() {_uniqueStorage()._wifiSettings = nil}

  var foregroundService: Bool {
    get {return _storage._foregroundService ?? false}
    set {_uniqueStorage()._foregroundService = newValue}
  }
  /// Returns true if `foregroundService` has been explicitly set.
  var hasForegroundService: Bool {return _storage._foregroundService != nil}
  /// Clears the value of `foregroundService`. Subsequent reads from it will return its default value.
  mutating func clearForegroundService() {_uniqueStorage()._foregroundService = nil}

  var inertialSettings: Messaging_AndroidInertialSettings {
    get {return _storage._inertialSettings ?? Messaging_AndroidInertialSettings()}
    set {_uniqueStorage()._inertialSettings = newValue}
  }
  /// Returns true if `inertialSettings` has been explicitly set.
  var hasInertialSettings: Bool {return _storage._inertialSettings != nil}
  /// Clears the value of `inertialSettings`. Subsequent reads from it will return its default value.
  mutating func clearInertialSettings() {_uniqueStorage()._inertialSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Messaging_AndroidGeoSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the min distance to travel before another update
  var minDistance: UInt32 {
    get {return _minDistance ?? 0}
    set {_minDistance = newValue}
  }
  /// Returns true if `minDistance` has been explicitly set.
  var hasMinDistance: Bool {return self._minDistance != nil}
  /// Clears the value of `minDistance`. Subsequent reads from it will return its default value.
  mutating func clearMinDistance() {self._minDistance = nil}

  /// the minimum time before another update
  var minTime: UInt64 {
    get {return _minTime ?? 0}
    set {_minTime = newValue}
  }
  /// Returns true if `minTime` has been explicitly set.
  var hasMinTime: Bool {return self._minTime != nil}
  /// Clears the value of `minTime`. Subsequent reads from it will return its default value.
  mutating func clearMinTime() {self._minTime = nil}

  var priority: Messaging_AndroidGeoSettings.Priority {
    get {return _priority ?? .highAccuracy}
    set {_priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  var hasPriority: Bool {return self._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  mutating func clearPriority() {self._priority = nil}

  var batchTime: UInt64 {
    get {return _batchTime ?? 0}
    set {_batchTime = newValue}
  }
  /// Returns true if `batchTime` has been explicitly set.
  var hasBatchTime: Bool {return self._batchTime != nil}
  /// Clears the value of `batchTime`. Subsequent reads from it will return its default value.
  mutating func clearBatchTime() {self._batchTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Priority: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///Android PRIORITY_HIGH_ACCURACY = 100
    case highAccuracy // = 0

    ///Android BALANCED_POWER_ACCURACY = 102;
    case balancedPowerAccuracy // = 1

    ///Android PRIORITY_LOW_POWER = 104;
    case lowPower // = 2

    ///Android PRIORITY_NO_POWER = 105;
    case noPower // = 3

    init() {
      self = .highAccuracy
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .highAccuracy
      case 1: self = .balancedPowerAccuracy
      case 2: self = .lowPower
      case 3: self = .noPower
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .highAccuracy: return 0
      case .balancedPowerAccuracy: return 1
      case .lowPower: return 2
      case .noPower: return 3
      }
    }

  }

  init() {}

  fileprivate var _minDistance: UInt32? = nil
  fileprivate var _minTime: UInt64? = nil
  fileprivate var _priority: Messaging_AndroidGeoSettings.Priority? = nil
  fileprivate var _batchTime: UInt64? = nil
}

#if swift(>=4.2)

extension Messaging_AndroidGeoSettings.Priority: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Messaging_AndroidBeaconSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///list of beacons to advertise
  var advertisements: [Messaging_BeaconAdvertisement] {
    get {return _storage._advertisements}
    set {_uniqueStorage()._advertisements = newValue}
  }

  ///scan and report rssi for these beacon families, on this cycle, with this filter
  var ranging: Messaging_BeaconRanging {
    get {return _storage._ranging ?? Messaging_BeaconRanging()}
    set {_uniqueStorage()._ranging = newValue}
  }
  /// Returns true if `ranging` has been explicitly set.
  var hasRanging: Bool {return _storage._ranging != nil}
  /// Clears the value of `ranging`. Subsequent reads from it will return its default value.
  mutating func clearRanging() {_uniqueStorage()._ranging = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Messaging_AndroidWifiSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {self._enabled = nil}

  var interval: UInt64 {
    get {return _interval ?? 0}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  mutating func clearInterval() {self._interval = nil}

  var state: String {
    get {return _state ?? String()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var rttEnabled: Bool {
    get {return _rttEnabled ?? false}
    set {_rttEnabled = newValue}
  }
  /// Returns true if `rttEnabled` has been explicitly set.
  var hasRttEnabled: Bool {return self._rttEnabled != nil}
  /// Clears the value of `rttEnabled`. Subsequent reads from it will return its default value.
  mutating func clearRttEnabled() {self._rttEnabled = nil}

  var rttInterval: UInt64 {
    get {return _rttInterval ?? 0}
    set {_rttInterval = newValue}
  }
  /// Returns true if `rttInterval` has been explicitly set.
  var hasRttInterval: Bool {return self._rttInterval != nil}
  /// Clears the value of `rttInterval`. Subsequent reads from it will return its default value.
  mutating func clearRttInterval() {self._rttInterval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enabled: Bool? = nil
  fileprivate var _interval: UInt64? = nil
  fileprivate var _state: String? = nil
  fileprivate var _rttEnabled: Bool? = nil
  fileprivate var _rttInterval: UInt64? = nil
}

struct Messaging_BeaconRegion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String {
    get {return _uuid ?? String()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var major: UInt32 {
    get {return _major ?? 0}
    set {_major = newValue}
  }
  /// Returns true if `major` has been explicitly set.
  var hasMajor: Bool {return self._major != nil}
  /// Clears the value of `major`. Subsequent reads from it will return its default value.
  mutating func clearMajor() {self._major = nil}

  var minor: UInt32 {
    get {return _minor ?? 0}
    set {_minor = newValue}
  }
  /// Returns true if `minor` has been explicitly set.
  var hasMinor: Bool {return self._minor != nil}
  /// Clears the value of `minor`. Subsequent reads from it will return its default value.
  mutating func clearMinor() {self._minor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uuid: String? = nil
  fileprivate var _major: UInt32? = nil
  fileprivate var _minor: UInt32? = nil
}

struct Messaging_BeaconAdvertisement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///must have UUID and major and minor. If they are missing, set to zero
  var identifier: Messaging_BeaconRegion {
    get {return _storage._identifier ?? Messaging_BeaconRegion()}
    set {_uniqueStorage()._identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return _storage._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {_uniqueStorage()._identifier = nil}

  /// the advertising period, if controllable
  var frequency: Messaging_BeaconAdvertisement.Frequency {
    get {return _storage._frequency ?? .lowFrequency}
    set {_uniqueStorage()._frequency = newValue}
  }
  /// Returns true if `frequency` has been explicitly set.
  var hasFrequency: Bool {return _storage._frequency != nil}
  /// Clears the value of `frequency`. Subsequent reads from it will return its default value.
  mutating func clearFrequency() {_uniqueStorage()._frequency = nil}

  var power: Messaging_BeaconAdvertisement.Power {
    get {return _storage._power ?? .ultralowPower}
    set {_uniqueStorage()._power = newValue}
  }
  /// Returns true if `power` has been explicitly set.
  var hasPower: Bool {return _storage._power != nil}
  /// Clears the value of `power`. Subsequent reads from it will return its default value.
  mutating func clearPower() {_uniqueStorage()._power = nil}

  ///how long to cycle on for in milliseconds
  var onPeriod: UInt64 {
    get {return _storage._onPeriod ?? 0}
    set {_uniqueStorage()._onPeriod = newValue}
  }
  /// Returns true if `onPeriod` has been explicitly set.
  var hasOnPeriod: Bool {return _storage._onPeriod != nil}
  /// Clears the value of `onPeriod`. Subsequent reads from it will return its default value.
  mutating func clearOnPeriod() {_uniqueStorage()._onPeriod = nil}

  ///how long to cycle off for in milliseconds
  var offPeriod: UInt64 {
    get {return _storage._offPeriod ?? 0}
    set {_uniqueStorage()._offPeriod = newValue}
  }
  /// Returns true if `offPeriod` has been explicitly set.
  var hasOffPeriod: Bool {return _storage._offPeriod != nil}
  /// Clears the value of `offPeriod`. Subsequent reads from it will return its default value.
  mutating func clearOffPeriod() {_uniqueStorage()._offPeriod = nil}

  ///the start time of the advertisment, add on+off period until you get a timestamp in the future
  var startTime: UInt64 {
    get {return _storage._startTime ?? 0}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  ///whether or not to repeat the on / off cycle permanently. Otherwise one shot for onperiod.
  var `repeat`: Bool {
    get {return _storage._repeat ?? false}
    set {_uniqueStorage()._repeat = newValue}
  }
  /// Returns true if ``repeat`` has been explicitly set.
  var hasRepeat: Bool {return _storage._repeat != nil}
  /// Clears the value of ``repeat``. Subsequent reads from it will return its default value.
  mutating func clearRepeat() {_uniqueStorage()._repeat = nil}

  var eid: Messaging_EID {
    get {return _storage._eid ?? Messaging_EID()}
    set {_uniqueStorage()._eid = newValue}
  }
  /// Returns true if `eid` has been explicitly set.
  var hasEid: Bool {return _storage._eid != nil}
  /// Clears the value of `eid`. Subsequent reads from it will return its default value.
  mutating func clearEid() {_uniqueStorage()._eid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Frequency: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///Equivalent to Android ADVERTISE_MODE_LOW_POWER = 1000ms
    case lowFrequency // = 0

    ///Equivalent to Android ADVERTISE_MODE_BALANCED =
    case balancedFrequency // = 1

    ///Equivalent to Android ADVERTISE_MODE_LOW_LATENCY = 100ms
    case highFrequency // = 2

    init() {
      self = .lowFrequency
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lowFrequency
      case 1: self = .balancedFrequency
      case 2: self = .highFrequency
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .lowFrequency: return 0
      case .balancedFrequency: return 1
      case .highFrequency: return 2
      }
    }

  }

  enum Power: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///Equivalent to Android ADVERTISE_TX_POWER_ULTRA_LOW
    case ultralowPower // = 0

    ///Equivalent to Android ADVERTISE_TX_POWER_LOW
    case lowPower // = 1

    ///Equivalent to Android ADVERTISE_TX_POWER_MEDIUM
    case mediumPower // = 2

    ///Equivalent to Android ADVERTISE_TX_POWER_HIGH
    case highPower // = 3

    init() {
      self = .ultralowPower
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ultralowPower
      case 1: self = .lowPower
      case 2: self = .mediumPower
      case 3: self = .highPower
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ultralowPower: return 0
      case .lowPower: return 1
      case .mediumPower: return 2
      case .highPower: return 3
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Messaging_BeaconAdvertisement.Frequency: CaseIterable {
  // Support synthesized by the compiler.
}

extension Messaging_BeaconAdvertisement.Power: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Messaging_EID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var secret: Data {
    get {return _secret ?? SwiftProtobuf.Internal.emptyData}
    set {_secret = newValue}
  }
  /// Returns true if `secret` has been explicitly set.
  var hasSecret: Bool {return self._secret != nil}
  /// Clears the value of `secret`. Subsequent reads from it will return its default value.
  mutating func clearSecret() {self._secret = nil}

  var k: UInt32 {
    get {return _k ?? 0}
    set {_k = newValue}
  }
  /// Returns true if `k` has been explicitly set.
  var hasK: Bool {return self._k != nil}
  /// Clears the value of `k`. Subsequent reads from it will return its default value.
  mutating func clearK() {self._k = nil}

  var clockOffset: UInt32 {
    get {return _clockOffset ?? 0}
    set {_clockOffset = newValue}
  }
  /// Returns true if `clockOffset` has been explicitly set.
  var hasClockOffset: Bool {return self._clockOffset != nil}
  /// Clears the value of `clockOffset`. Subsequent reads from it will return its default value.
  mutating func clearClockOffset() {self._clockOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _secret: Data? = nil
  fileprivate var _k: UInt32? = nil
  fileprivate var _clockOffset: UInt32? = nil
}

struct Messaging_BeaconMonitoring {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///regions to monitor for (continually)
  var regions: [Messaging_BeaconRegion] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Messaging_BeaconRanging {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The max time in milliseconds to range for. If the app is still running after this time, stop ranging.
  var maxRunTime: UInt64 {
    get {return _storage._maxRunTime ?? 0}
    set {_uniqueStorage()._maxRunTime = newValue}
  }
  /// Returns true if `maxRunTime` has been explicitly set.
  var hasMaxRunTime: Bool {return _storage._maxRunTime != nil}
  /// Clears the value of `maxRunTime`. Subsequent reads from it will return its default value.
  mutating func clearMaxRunTime() {_uniqueStorage()._maxRunTime = nil}

  ///minimum off period - must work across multiple wake up / kills. Don't start ranging again until at least this time has elapsed.
  var minOffTime: UInt64 {
    get {return _storage._minOffTime ?? 0}
    set {_uniqueStorage()._minOffTime = newValue}
  }
  /// Returns true if `minOffTime` has been explicitly set.
  var hasMinOffTime: Bool {return _storage._minOffTime != nil}
  /// Clears the value of `minOffTime`. Subsequent reads from it will return its default value.
  mutating func clearMinOffTime() {_uniqueStorage()._minOffTime = nil}

  ///regions to be ranged. If none present then anything available is reported
  var regions: [Messaging_BeaconRegion] {
    get {return _storage._regions}
    set {_uniqueStorage()._regions = newValue}
  }

  ///optional - aggregation and filter to be applied to a batch of observations before sending.
  var filter: Messaging_BeaconFilter {
    get {return _storage._filter ?? Messaging_BeaconFilter()}
    set {_uniqueStorage()._filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return _storage._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {_uniqueStorage()._filter = nil}

  var nonBeaconScan: Bool {
    get {return _storage._nonBeaconScan ?? false}
    set {_uniqueStorage()._nonBeaconScan = newValue}
  }
  /// Returns true if `nonBeaconScan` has been explicitly set.
  var hasNonBeaconScan: Bool {return _storage._nonBeaconScan != nil}
  /// Clears the value of `nonBeaconScan`. Subsequent reads from it will return its default value.
  mutating func clearNonBeaconScan() {_uniqueStorage()._nonBeaconScan = nil}

  var eddystoneScan: Bool {
    get {return _storage._eddystoneScan ?? false}
    set {_uniqueStorage()._eddystoneScan = newValue}
  }
  /// Returns true if `eddystoneScan` has been explicitly set.
  var hasEddystoneScan: Bool {return _storage._eddystoneScan != nil}
  /// Clears the value of `eddystoneScan`. Subsequent reads from it will return its default value.
  mutating func clearEddystoneScan() {_uniqueStorage()._eddystoneScan = nil}

  var iBeaconScan: Bool {
    get {return _storage._iBeaconScan ?? false}
    set {_uniqueStorage()._iBeaconScan = newValue}
  }
  /// Returns true if `iBeaconScan` has been explicitly set.
  var hasIBeaconScan: Bool {return _storage._iBeaconScan != nil}
  /// Clears the value of `iBeaconScan`. Subsequent reads from it will return its default value.
  mutating func clearIBeaconScan() {_uniqueStorage()._iBeaconScan = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Messaging_BeaconFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Window duration in milliseconds. Observations of unique beacon are averaged over the window
  var windowSize: UInt64 {
    get {return _windowSize ?? 0}
    set {_windowSize = newValue}
  }
  /// Returns true if `windowSize` has been explicitly set.
  var hasWindowSize: Bool {return self._windowSize != nil}
  /// Clears the value of `windowSize`. Subsequent reads from it will return its default value.
  mutating func clearWindowSize() {self._windowSize = nil}

  ///The maximum number of rssi observations to send in any one window. Highest rssi takes precedent.
  var maxObservations: UInt32 {
    get {return _maxObservations ?? 0}
    set {_maxObservations = newValue}
  }
  /// Returns true if `maxObservations` has been explicitly set.
  var hasMaxObservations: Bool {return self._maxObservations != nil}
  /// Clears the value of `maxObservations`. Subsequent reads from it will return its default value.
  mutating func clearMaxObservations() {self._maxObservations = nil}

  ///don't report these specific beacon families
  var excludeRegions: [Messaging_BeaconRegion] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _windowSize: UInt64? = nil
  fileprivate var _maxObservations: UInt32? = nil
}

struct Messaging_AndroidInertialSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {self._enabled = nil}

  var frequency: Messaging_AndroidInertialSettings.Frequency {
    get {return _frequency ?? .fastest}
    set {_frequency = newValue}
  }
  /// Returns true if `frequency` has been explicitly set.
  var hasFrequency: Bool {return self._frequency != nil}
  /// Clears the value of `frequency`. Subsequent reads from it will return its default value.
  mutating func clearFrequency() {self._frequency = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Frequency: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case fastest // = 1
    case game // = 2
    case ui // = 3
    case normal // = 4

    init() {
      self = .fastest
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .fastest
      case 2: self = .game
      case 3: self = .ui
      case 4: self = .normal
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .fastest: return 1
      case .game: return 2
      case .ui: return 3
      case .normal: return 4
      }
    }

  }

  init() {}

  fileprivate var _enabled: Bool? = nil
  fileprivate var _frequency: Messaging_AndroidInertialSettings.Frequency? = nil
}

#if swift(>=4.2)

extension Messaging_AndroidInertialSettings.Frequency: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Messaging_GlobalSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///no longer send string representation - have to parse the bytes
  var id: Data {
    get {return _id ?? SwiftProtobuf.Internal.emptyData}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  ///the time in milliseconds to ensure ensure radio silence between batch sends
  var radioSilence: UInt64 {
    get {return _radioSilence ?? 0}
    set {_radioSilence = newValue}
  }
  /// Returns true if `radioSilence` has been explicitly set.
  var hasRadioSilence: Bool {return self._radioSilence != nil}
  /// Clears the value of `radioSilence`. Subsequent reads from it will return its default value.
  mutating func clearRadioSilence() {self._radioSilence = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Data? = nil
  fileprivate var _radioSilence: UInt64? = nil
}

struct Messaging_ClientLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Messaging_ClientLocationRequest.TypeEnum {
    get {return _type ?? .single}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case single // = 1
    case ongoing // = 2
    case stop // = 3

    init() {
      self = .single
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .single
      case 2: self = .ongoing
      case 3: self = .stop
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .single: return 1
      case .ongoing: return 2
      case .stop: return 3
      }
    }

  }

  init() {}

  fileprivate var _type: Messaging_ClientLocationRequest.TypeEnum? = nil
}

#if swift(>=4.2)

extension Messaging_ClientLocationRequest.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Messaging_ClientLocationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var error: Double {
    get {return _error ?? 0}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var headingOffset: Double {
    get {return _headingOffset ?? 0}
    set {_headingOffset = newValue}
  }
  /// Returns true if `headingOffset` has been explicitly set.
  var hasHeadingOffset: Bool {return self._headingOffset != nil}
  /// Clears the value of `headingOffset`. Subsequent reads from it will return its default value.
  mutating func clearHeadingOffset() {self._headingOffset = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _error: Double? = nil
  fileprivate var _headingOffset: Double? = nil
  fileprivate var _timestamp: UInt64? = nil
}

///Client Messages
struct Messaging_ClientMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locationMessage: [Messaging_LocationMessage] {
    get {return _storage._locationMessage}
    set {_uniqueStorage()._locationMessage = newValue}
  }

  var bluetoothMessage: [Messaging_Bluetooth] {
    get {return _storage._bluetoothMessage}
    set {_uniqueStorage()._bluetoothMessage = newValue}
  }

  var ibeaconMessage: [Messaging_IBeacon] {
    get {return _storage._ibeaconMessage}
    set {_uniqueStorage()._ibeaconMessage = newValue}
  }

  var wifiMessage: [Messaging_WifiMessage] {
    get {return _storage._wifiMessage}
    set {_uniqueStorage()._wifiMessage = newValue}
  }

  var marker: Messaging_MarkerMessage {
    get {return _storage._marker ?? Messaging_MarkerMessage()}
    set {_uniqueStorage()._marker = newValue}
  }
  /// Returns true if `marker` has been explicitly set.
  var hasMarker: Bool {return _storage._marker != nil}
  /// Clears the value of `marker`. Subsequent reads from it will return its default value.
  mutating func clearMarker() {_uniqueStorage()._marker = nil}

  var alias: [Messaging_AliasMessage] {
    get {return _storage._alias}
    set {_uniqueStorage()._alias = newValue}
  }

  var capability: Messaging_Capability {
    get {return _storage._capability ?? Messaging_Capability()}
    set {_uniqueStorage()._capability = newValue}
  }
  /// Returns true if `capability` has been explicitly set.
  var hasCapability: Bool {return _storage._capability != nil}
  /// Clears the value of `capability`. Subsequent reads from it will return its default value.
  mutating func clearCapability() {_uniqueStorage()._capability = nil}

  var battery: Messaging_Battery {
    get {return _storage._battery ?? Messaging_Battery()}
    set {_uniqueStorage()._battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return _storage._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {_uniqueStorage()._battery = nil}

  ///for server use only
  var clientKey: String {
    get {return _storage._clientKey ?? String()}
    set {_uniqueStorage()._clientKey = newValue}
  }
  /// Returns true if `clientKey` has been explicitly set.
  var hasClientKey: Bool {return _storage._clientKey != nil}
  /// Clears the value of `clientKey`. Subsequent reads from it will return its default value.
  mutating func clearClientKey() {_uniqueStorage()._clientKey = nil}

  ///for server use only
  var deviceID: Data {
    get {return _storage._deviceID ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  var hasDeviceID: Bool {return _storage._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  mutating func clearDeviceID() {_uniqueStorage()._deviceID = nil}

  ///for server use only
  var receivedTimestamp: UInt64 {
    get {return _storage._receivedTimestamp ?? 0}
    set {_uniqueStorage()._receivedTimestamp = newValue}
  }
  /// Returns true if `receivedTimestamp` has been explicitly set.
  var hasReceivedTimestamp: Bool {return _storage._receivedTimestamp != nil}
  /// Clears the value of `receivedTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearReceivedTimestamp() {_uniqueStorage()._receivedTimestamp = nil}

  var sentTime: UInt64 {
    get {return _storage._sentTime ?? 0}
    set {_uniqueStorage()._sentTime = newValue}
  }
  /// Returns true if `sentTime` has been explicitly set.
  var hasSentTime: Bool {return _storage._sentTime != nil}
  /// Clears the value of `sentTime`. Subsequent reads from it will return its default value.
  mutating func clearSentTime() {_uniqueStorage()._sentTime = nil}

  var iosCapability: Messaging_IosCapability {
    get {return _storage._iosCapability ?? Messaging_IosCapability()}
    set {_uniqueStorage()._iosCapability = newValue}
  }
  /// Returns true if `iosCapability` has been explicitly set.
  var hasIosCapability: Bool {return _storage._iosCapability != nil}
  /// Clears the value of `iosCapability`. Subsequent reads from it will return its default value.
  mutating func clearIosCapability() {_uniqueStorage()._iosCapability = nil}

  var messageIdentifier: Data {
    get {return _storage._messageIdentifier ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._messageIdentifier = newValue}
  }
  /// Returns true if `messageIdentifier` has been explicitly set.
  var hasMessageIdentifier: Bool {return _storage._messageIdentifier != nil}
  /// Clears the value of `messageIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearMessageIdentifier() {_uniqueStorage()._messageIdentifier = nil}

  var userInputLocationMessage: [Messaging_UserInputLocationMessage] {
    get {return _storage._userInputLocationMessage}
    set {_uniqueStorage()._userInputLocationMessage = newValue}
  }

  var surveryMode: Bool {
    get {return _storage._surveryMode ?? false}
    set {_uniqueStorage()._surveryMode = newValue}
  }
  /// Returns true if `surveryMode` has been explicitly set.
  var hasSurveryMode: Bool {return _storage._surveryMode != nil}
  /// Clears the value of `surveryMode`. Subsequent reads from it will return its default value.
  mutating func clearSurveryMode() {_uniqueStorage()._surveryMode = nil}

  var wifiRttMessage: [Messaging_WifiRTTMessage] {
    get {return _storage._wifiRttMessage}
    set {_uniqueStorage()._wifiRttMessage = newValue}
  }

  var eddystonemessage: [Messaging_EddystoneBeacon] {
    get {return _storage._eddystonemessage}
    set {_uniqueStorage()._eddystonemessage = newValue}
  }

  var step: [Messaging_Step] {
    get {return _storage._step}
    set {_uniqueStorage()._step = newValue}
  }

  var locationRequest: Messaging_ClientLocationRequest {
    get {return _storage._locationRequest ?? Messaging_ClientLocationRequest()}
    set {_uniqueStorage()._locationRequest = newValue}
  }
  /// Returns true if `locationRequest` has been explicitly set.
  var hasLocationRequest: Bool {return _storage._locationRequest != nil}
  /// Clears the value of `locationRequest`. Subsequent reads from it will return its default value.
  mutating func clearLocationRequest() {_uniqueStorage()._locationRequest = nil}

  var circularGeoFenceEvents: [Messaging_CircularGeoFenceEvent] {
    get {return _storage._circularGeoFenceEvents}
    set {_uniqueStorage()._circularGeoFenceEvents = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Messaging_CircularGeoFenceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var radius: Double {
    get {return _radius ?? 0}
    set {_radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return self._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {self._radius = nil}

  var type: Messaging_CircularGeoFenceEvent.TypeEnum {
    get {return _type ?? .entry}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case entry // = 1
    case exit // = 2

    init() {
      self = .entry
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .entry
      case 2: self = .exit
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .entry: return 1
      case .exit: return 2
      }
    }

  }

  init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _radius: Double? = nil
  fileprivate var _type: Messaging_CircularGeoFenceEvent.TypeEnum? = nil
}

#if swift(>=4.2)

extension Messaging_CircularGeoFenceEvent.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Messaging_UserInputLocationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var altitude: Double {
    get {return _altitude ?? 0}
    set {_altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  var hasAltitude: Bool {return self._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  mutating func clearAltitude() {self._altitude = nil}

  var x: Double {
    get {return _x ?? 0}
    set {_x = newValue}
  }
  /// Returns true if `x` has been explicitly set.
  var hasX: Bool {return self._x != nil}
  /// Clears the value of `x`. Subsequent reads from it will return its default value.
  mutating func clearX() {self._x = nil}

  var y: Double {
    get {return _y ?? 0}
    set {_y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  var hasY: Bool {return self._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  mutating func clearY() {self._y = nil}

  var z: Double {
    get {return _z ?? 0}
    set {_z = newValue}
  }
  /// Returns true if `z` has been explicitly set.
  var hasZ: Bool {return self._z != nil}
  /// Clears the value of `z`. Subsequent reads from it will return its default value.
  mutating func clearZ() {self._z = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _altitude: Double? = nil
  fileprivate var _x: Double? = nil
  fileprivate var _y: Double? = nil
  fileprivate var _z: Double? = nil
  fileprivate var _timestamp: UInt64? = nil
}

struct Messaging_LocationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///field types and numbers are backward compatible
  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var altitude: Double {
    get {return _altitude ?? 0}
    set {_altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  var hasAltitude: Bool {return self._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  mutating func clearAltitude() {self._altitude = nil}

  var horizontalAccuracy: Double {
    get {return _horizontalAccuracy ?? 0}
    set {_horizontalAccuracy = newValue}
  }
  /// Returns true if `horizontalAccuracy` has been explicitly set.
  var hasHorizontalAccuracy: Bool {return self._horizontalAccuracy != nil}
  /// Clears the value of `horizontalAccuracy`. Subsequent reads from it will return its default value.
  mutating func clearHorizontalAccuracy() {self._horizontalAccuracy = nil}

  var verticalAccuracy: Double {
    get {return _verticalAccuracy ?? 0}
    set {_verticalAccuracy = newValue}
  }
  /// Returns true if `verticalAccuracy` has been explicitly set.
  var hasVerticalAccuracy: Bool {return self._verticalAccuracy != nil}
  /// Clears the value of `verticalAccuracy`. Subsequent reads from it will return its default value.
  mutating func clearVerticalAccuracy() {self._verticalAccuracy = nil}

  ///iOS has course, Android has bearing. Are they the same?
  var course: Double {
    get {return _course ?? 0}
    set {_course = newValue}
  }
  /// Returns true if `course` has been explicitly set.
  var hasCourse: Bool {return self._course != nil}
  /// Clears the value of `course`. Subsequent reads from it will return its default value.
  mutating func clearCourse() {self._course = nil}

  var speed: Double {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  mutating func clearSpeed() {self._speed = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var isMockLocation: Bool {
    get {return _isMockLocation ?? false}
    set {_isMockLocation = newValue}
  }
  /// Returns true if `isMockLocation` has been explicitly set.
  var hasIsMockLocation: Bool {return self._isMockLocation != nil}
  /// Clears the value of `isMockLocation`. Subsequent reads from it will return its default value.
  mutating func clearIsMockLocation() {self._isMockLocation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _altitude: Double? = nil
  fileprivate var _horizontalAccuracy: Double? = nil
  fileprivate var _verticalAccuracy: Double? = nil
  fileprivate var _course: Double? = nil
  fileprivate var _speed: Double? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _isMockLocation: Bool? = nil
}

struct Messaging_Bluetooth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///field types and numbers are backward compatible
  ///only used for reporting non iBeacon BLE scans
  var identifier: Data {
    get {return _identifier ?? SwiftProtobuf.Internal.emptyData}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var mac: Data {
    get {return _mac ?? SwiftProtobuf.Internal.emptyData}
    set {_mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  var hasMac: Bool {return self._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  mutating func clearMac() {self._mac = nil}

  var rssi: Int32 {
    get {return _rssi ?? 0}
    set {_rssi = newValue}
  }
  /// Returns true if `rssi` has been explicitly set.
  var hasRssi: Bool {return self._rssi != nil}
  /// Clears the value of `rssi`. Subsequent reads from it will return its default value.
  mutating func clearRssi() {self._rssi = nil}

  var tx: Int32 {
    get {return _tx ?? 0}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var averagingWindow: UInt32 {
    get {return _averagingWindow ?? 0}
    set {_averagingWindow = newValue}
  }
  /// Returns true if `averagingWindow` has been explicitly set.
  var hasAveragingWindow: Bool {return self._averagingWindow != nil}
  /// Clears the value of `averagingWindow`. Subsequent reads from it will return its default value.
  mutating func clearAveragingWindow() {self._averagingWindow = nil}

  var amountAveraged: UInt32 {
    get {return _amountAveraged ?? 0}
    set {_amountAveraged = newValue}
  }
  /// Returns true if `amountAveraged` has been explicitly set.
  var hasAmountAveraged: Bool {return self._amountAveraged != nil}
  /// Clears the value of `amountAveraged`. Subsequent reads from it will return its default value.
  mutating func clearAmountAveraged() {self._amountAveraged = nil}

  var scanData: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: Data? = nil
  fileprivate var _mac: Data? = nil
  fileprivate var _rssi: Int32? = nil
  fileprivate var _tx: Int32? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _averagingWindow: UInt32? = nil
  fileprivate var _amountAveraged: UInt32? = nil
}

struct Messaging_IBeacon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///field types and numbers are backward compatible
  /// used by iOS and Android for reporting beacon observations
  var uuid: Data {
    get {return _uuid ?? SwiftProtobuf.Internal.emptyData}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var major: UInt32 {
    get {return _major ?? 0}
    set {_major = newValue}
  }
  /// Returns true if `major` has been explicitly set.
  var hasMajor: Bool {return self._major != nil}
  /// Clears the value of `major`. Subsequent reads from it will return its default value.
  mutating func clearMajor() {self._major = nil}

  var minor: UInt32 {
    get {return _minor ?? 0}
    set {_minor = newValue}
  }
  /// Returns true if `minor` has been explicitly set.
  var hasMinor: Bool {return self._minor != nil}
  /// Clears the value of `minor`. Subsequent reads from it will return its default value.
  mutating func clearMinor() {self._minor = nil}

  var rssi: Int32 {
    get {return _rssi ?? 0}
    set {_rssi = newValue}
  }
  /// Returns true if `rssi` has been explicitly set.
  var hasRssi: Bool {return self._rssi != nil}
  /// Clears the value of `rssi`. Subsequent reads from it will return its default value.
  mutating func clearRssi() {self._rssi = nil}

  var proximity: UInt32 {
    get {return _proximity ?? 0}
    set {_proximity = newValue}
  }
  /// Returns true if `proximity` has been explicitly set.
  var hasProximity: Bool {return self._proximity != nil}
  /// Clears the value of `proximity`. Subsequent reads from it will return its default value.
  mutating func clearProximity() {self._proximity = nil}

  var accuracy: Double {
    get {return _accuracy ?? 0}
    set {_accuracy = newValue}
  }
  /// Returns true if `accuracy` has been explicitly set.
  var hasAccuracy: Bool {return self._accuracy != nil}
  /// Clears the value of `accuracy`. Subsequent reads from it will return its default value.
  mutating func clearAccuracy() {self._accuracy = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var averagingWindow: UInt64 {
    get {return _averagingWindow ?? 0}
    set {_averagingWindow = newValue}
  }
  /// Returns true if `averagingWindow` has been explicitly set.
  var hasAveragingWindow: Bool {return self._averagingWindow != nil}
  /// Clears the value of `averagingWindow`. Subsequent reads from it will return its default value.
  mutating func clearAveragingWindow() {self._averagingWindow = nil}

  var amountAveraged: UInt32 {
    get {return _amountAveraged ?? 0}
    set {_amountAveraged = newValue}
  }
  /// Returns true if `amountAveraged` has been explicitly set.
  var hasAmountAveraged: Bool {return self._amountAveraged != nil}
  /// Clears the value of `amountAveraged`. Subsequent reads from it will return its default value.
  mutating func clearAmountAveraged() {self._amountAveraged = nil}

  var batteryLevel: UInt32 {
    get {return _batteryLevel ?? 0}
    set {_batteryLevel = newValue}
  }
  /// Returns true if `batteryLevel` has been explicitly set.
  var hasBatteryLevel: Bool {return self._batteryLevel != nil}
  /// Clears the value of `batteryLevel`. Subsequent reads from it will return its default value.
  mutating func clearBatteryLevel() {self._batteryLevel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uuid: Data? = nil
  fileprivate var _major: UInt32? = nil
  fileprivate var _minor: UInt32? = nil
  fileprivate var _rssi: Int32? = nil
  fileprivate var _proximity: UInt32? = nil
  fileprivate var _accuracy: Double? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _averagingWindow: UInt64? = nil
  fileprivate var _amountAveraged: UInt32? = nil
  fileprivate var _batteryLevel: UInt32? = nil
}

struct Messaging_EddystoneBeacon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///field types and numbers are backward compatible
  var eid: Data {
    get {return _eid ?? SwiftProtobuf.Internal.emptyData}
    set {_eid = newValue}
  }
  /// Returns true if `eid` has been explicitly set.
  var hasEid: Bool {return self._eid != nil}
  /// Clears the value of `eid`. Subsequent reads from it will return its default value.
  mutating func clearEid() {self._eid = nil}

  var mac: Data {
    get {return _mac ?? SwiftProtobuf.Internal.emptyData}
    set {_mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  var hasMac: Bool {return self._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  mutating func clearMac() {self._mac = nil}

  var tx: Int32 {
    get {return _tx ?? 0}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var rssi: Int32 {
    get {return _rssi ?? 0}
    set {_rssi = newValue}
  }
  /// Returns true if `rssi` has been explicitly set.
  var hasRssi: Bool {return self._rssi != nil}
  /// Clears the value of `rssi`. Subsequent reads from it will return its default value.
  mutating func clearRssi() {self._rssi = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var averagingWindow: UInt64 {
    get {return _averagingWindow ?? 0}
    set {_averagingWindow = newValue}
  }
  /// Returns true if `averagingWindow` has been explicitly set.
  var hasAveragingWindow: Bool {return self._averagingWindow != nil}
  /// Clears the value of `averagingWindow`. Subsequent reads from it will return its default value.
  mutating func clearAveragingWindow() {self._averagingWindow = nil}

  var amountAveraged: UInt32 {
    get {return _amountAveraged ?? 0}
    set {_amountAveraged = newValue}
  }
  /// Returns true if `amountAveraged` has been explicitly set.
  var hasAmountAveraged: Bool {return self._amountAveraged != nil}
  /// Clears the value of `amountAveraged`. Subsequent reads from it will return its default value.
  mutating func clearAmountAveraged() {self._amountAveraged = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eid: Data? = nil
  fileprivate var _mac: Data? = nil
  fileprivate var _tx: Int32? = nil
  fileprivate var _rssi: Int32? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _averagingWindow: UInt64? = nil
  fileprivate var _amountAveraged: UInt32? = nil
}

struct Messaging_WifiMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bssid: String {
    get {return _bssid ?? String()}
    set {_bssid = newValue}
  }
  /// Returns true if `bssid` has been explicitly set.
  var hasBssid: Bool {return self._bssid != nil}
  /// Clears the value of `bssid`. Subsequent reads from it will return its default value.
  mutating func clearBssid() {self._bssid = nil}

  var ssid: String {
    get {return _ssid ?? String()}
    set {_ssid = newValue}
  }
  /// Returns true if `ssid` has been explicitly set.
  var hasSsid: Bool {return self._ssid != nil}
  /// Clears the value of `ssid`. Subsequent reads from it will return its default value.
  mutating func clearSsid() {self._ssid = nil}

  var rssi: Int32 {
    get {return _rssi ?? 0}
    set {_rssi = newValue}
  }
  /// Returns true if `rssi` has been explicitly set.
  var hasRssi: Bool {return self._rssi != nil}
  /// Clears the value of `rssi`. Subsequent reads from it will return its default value.
  mutating func clearRssi() {self._rssi = nil}

  var frequency: UInt32 {
    get {return _frequency ?? 0}
    set {_frequency = newValue}
  }
  /// Returns true if `frequency` has been explicitly set.
  var hasFrequency: Bool {return self._frequency != nil}
  /// Clears the value of `frequency`. Subsequent reads from it will return its default value.
  mutating func clearFrequency() {self._frequency = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var centerFreq0: UInt32 {
    get {return _centerFreq0 ?? 0}
    set {_centerFreq0 = newValue}
  }
  /// Returns true if `centerFreq0` has been explicitly set.
  var hasCenterFreq0: Bool {return self._centerFreq0 != nil}
  /// Clears the value of `centerFreq0`. Subsequent reads from it will return its default value.
  mutating func clearCenterFreq0() {self._centerFreq0 = nil}

  var centerFreq1: UInt32 {
    get {return _centerFreq1 ?? 0}
    set {_centerFreq1 = newValue}
  }
  /// Returns true if `centerFreq1` has been explicitly set.
  var hasCenterFreq1: Bool {return self._centerFreq1 != nil}
  /// Clears the value of `centerFreq1`. Subsequent reads from it will return its default value.
  mutating func clearCenterFreq1() {self._centerFreq1 = nil}

  var channelWidth: Messaging_WifiMessage.ChannelWidth {
    get {return _channelWidth ?? .channelWidth160Mhz}
    set {_channelWidth = newValue}
  }
  /// Returns true if `channelWidth` has been explicitly set.
  var hasChannelWidth: Bool {return self._channelWidth != nil}
  /// Clears the value of `channelWidth`. Subsequent reads from it will return its default value.
  mutating func clearChannelWidth() {self._channelWidth = nil}

  var rttResponder: Bool {
    get {return _rttResponder ?? false}
    set {_rttResponder = newValue}
  }
  /// Returns true if `rttResponder` has been explicitly set.
  var hasRttResponder: Bool {return self._rttResponder != nil}
  /// Clears the value of `rttResponder`. Subsequent reads from it will return its default value.
  mutating func clearRttResponder() {self._rttResponder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChannelWidth: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case channelWidth160Mhz // = 1
    case channelWidth20Mhz // = 2
    case channelWidth40Mhz // = 3
    case channelWidth80Mhz // = 4
    case channelWidth80MhzPlusMhz // = 5

    init() {
      self = .channelWidth160Mhz
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .channelWidth160Mhz
      case 2: self = .channelWidth20Mhz
      case 3: self = .channelWidth40Mhz
      case 4: self = .channelWidth80Mhz
      case 5: self = .channelWidth80MhzPlusMhz
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .channelWidth160Mhz: return 1
      case .channelWidth20Mhz: return 2
      case .channelWidth40Mhz: return 3
      case .channelWidth80Mhz: return 4
      case .channelWidth80MhzPlusMhz: return 5
      }
    }

  }

  init() {}

  fileprivate var _bssid: String? = nil
  fileprivate var _ssid: String? = nil
  fileprivate var _rssi: Int32? = nil
  fileprivate var _frequency: UInt32? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _centerFreq0: UInt32? = nil
  fileprivate var _centerFreq1: UInt32? = nil
  fileprivate var _channelWidth: Messaging_WifiMessage.ChannelWidth? = nil
  fileprivate var _rttResponder: Bool? = nil
}

#if swift(>=4.2)

extension Messaging_WifiMessage.ChannelWidth: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Messaging_WifiRTTMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accessPoint: Messaging_WifiMessage {
    get {return _storage._accessPoint ?? Messaging_WifiMessage()}
    set {_uniqueStorage()._accessPoint = newValue}
  }
  /// Returns true if `accessPoint` has been explicitly set.
  var hasAccessPoint: Bool {return _storage._accessPoint != nil}
  /// Clears the value of `accessPoint`. Subsequent reads from it will return its default value.
  mutating func clearAccessPoint() {_uniqueStorage()._accessPoint = nil}

  var distance: Int32 {
    get {return _storage._distance ?? 0}
    set {_uniqueStorage()._distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  var hasDistance: Bool {return _storage._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  mutating func clearDistance() {_uniqueStorage()._distance = nil}

  var distanceStdDev: Int32 {
    get {return _storage._distanceStdDev ?? 0}
    set {_uniqueStorage()._distanceStdDev = newValue}
  }
  /// Returns true if `distanceStdDev` has been explicitly set.
  var hasDistanceStdDev: Bool {return _storage._distanceStdDev != nil}
  /// Clears the value of `distanceStdDev`. Subsequent reads from it will return its default value.
  mutating func clearDistanceStdDev() {_uniqueStorage()._distanceStdDev = nil}

  var attemptedMeasurements: UInt32 {
    get {return _storage._attemptedMeasurements ?? 0}
    set {_uniqueStorage()._attemptedMeasurements = newValue}
  }
  /// Returns true if `attemptedMeasurements` has been explicitly set.
  var hasAttemptedMeasurements: Bool {return _storage._attemptedMeasurements != nil}
  /// Clears the value of `attemptedMeasurements`. Subsequent reads from it will return its default value.
  mutating func clearAttemptedMeasurements() {_uniqueStorage()._attemptedMeasurements = nil}

  var successfulMeasurements: UInt32 {
    get {return _storage._successfulMeasurements ?? 0}
    set {_uniqueStorage()._successfulMeasurements = newValue}
  }
  /// Returns true if `successfulMeasurements` has been explicitly set.
  var hasSuccessfulMeasurements: Bool {return _storage._successfulMeasurements != nil}
  /// Clears the value of `successfulMeasurements`. Subsequent reads from it will return its default value.
  mutating func clearSuccessfulMeasurements() {_uniqueStorage()._successfulMeasurements = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Messaging_MarkerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var time: UInt64 {
    get {return _time ?? 0}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: String? = nil
  fileprivate var _time: UInt64? = nil
}

struct Messaging_Capability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///need to amend this if we're going to properly implement cross platform
  var hasBle_p: Bool {
    get {return _hasBle_p ?? false}
    set {_hasBle_p = newValue}
  }
  /// Returns true if `hasBle_p` has been explicitly set.
  var hasHasBle_p: Bool {return self._hasBle_p != nil}
  /// Clears the value of `hasBle_p`. Subsequent reads from it will return its default value.
  mutating func clearHasBle_p() {self._hasBle_p = nil}

  var canAdvertise: Bool {
    get {return _canAdvertise ?? false}
    set {_canAdvertise = newValue}
  }
  /// Returns true if `canAdvertise` has been explicitly set.
  var hasCanAdvertise: Bool {return self._canAdvertise != nil}
  /// Clears the value of `canAdvertise`. Subsequent reads from it will return its default value.
  mutating func clearCanAdvertise() {self._canAdvertise = nil}

  var isBton: Bool {
    get {return _isBton ?? false}
    set {_isBton = newValue}
  }
  /// Returns true if `isBton` has been explicitly set.
  var hasIsBton: Bool {return self._isBton != nil}
  /// Clears the value of `isBton`. Subsequent reads from it will return its default value.
  mutating func clearIsBton() {self._isBton = nil}

  var hasLocationPermission_p: Bool {
    get {return _hasLocationPermission_p ?? false}
    set {_hasLocationPermission_p = newValue}
  }
  /// Returns true if `hasLocationPermission_p` has been explicitly set.
  var hasHasLocationPermission_p: Bool {return self._hasLocationPermission_p != nil}
  /// Clears the value of `hasLocationPermission_p`. Subsequent reads from it will return its default value.
  mutating func clearHasLocationPermission_p() {self._hasLocationPermission_p = nil}

  var isGpson: Bool {
    get {return _isGpson ?? false}
    set {_isGpson = newValue}
  }
  /// Returns true if `isGpson` has been explicitly set.
  var hasIsGpson: Bool {return self._isGpson != nil}
  /// Clears the value of `isGpson`. Subsequent reads from it will return its default value.
  mutating func clearIsGpson() {self._isGpson = nil}

  var foregroundService: Bool {
    get {return _foregroundService ?? false}
    set {_foregroundService = newValue}
  }
  /// Returns true if `foregroundService` has been explicitly set.
  var hasForegroundService: Bool {return self._foregroundService != nil}
  /// Clears the value of `foregroundService`. Subsequent reads from it will return its default value.
  mutating func clearForegroundService() {self._foregroundService = nil}

  var expiryTime: UInt64 {
    get {return _expiryTime ?? 0}
    set {_expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  var hasExpiryTime: Bool {return self._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  mutating func clearExpiryTime() {self._expiryTime = nil}

  var rtt: Bool {
    get {return _rtt ?? false}
    set {_rtt = newValue}
  }
  /// Returns true if `rtt` has been explicitly set.
  var hasRtt: Bool {return self._rtt != nil}
  /// Clears the value of `rtt`. Subsequent reads from it will return its default value.
  mutating func clearRtt() {self._rtt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hasBle_p: Bool? = nil
  fileprivate var _canAdvertise: Bool? = nil
  fileprivate var _isBton: Bool? = nil
  fileprivate var _hasLocationPermission_p: Bool? = nil
  fileprivate var _isGpson: Bool? = nil
  fileprivate var _foregroundService: Bool? = nil
  fileprivate var _expiryTime: UInt64? = nil
  fileprivate var _rtt: Bool? = nil
}

struct Messaging_IosCapability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locationServices: Bool {
    get {return _locationServices ?? false}
    set {_locationServices = newValue}
  }
  /// Returns true if `locationServices` has been explicitly set.
  var hasLocationServices: Bool {return self._locationServices != nil}
  /// Clears the value of `locationServices`. Subsequent reads from it will return its default value.
  mutating func clearLocationServices() {self._locationServices = nil}

  var locationAuthStatus: Messaging_IosCapability.LocationAuthStatus {
    get {return _locationAuthStatus ?? .notDetermined}
    set {_locationAuthStatus = newValue}
  }
  /// Returns true if `locationAuthStatus` has been explicitly set.
  var hasLocationAuthStatus: Bool {return self._locationAuthStatus != nil}
  /// Clears the value of `locationAuthStatus`. Subsequent reads from it will return its default value.
  mutating func clearLocationAuthStatus() {self._locationAuthStatus = nil}

  var bluetoothHardware: Messaging_IosCapability.BluetoothHardware {
    get {return _bluetoothHardware ?? .off}
    set {_bluetoothHardware = newValue}
  }
  /// Returns true if `bluetoothHardware` has been explicitly set.
  var hasBluetoothHardware: Bool {return self._bluetoothHardware != nil}
  /// Clears the value of `bluetoothHardware`. Subsequent reads from it will return its default value.
  mutating func clearBluetoothHardware() {self._bluetoothHardware = nil}

  var batteryState: Messaging_IosCapability.BatteryState {
    get {return _batteryState ?? .notDefined}
    set {_batteryState = newValue}
  }
  /// Returns true if `batteryState` has been explicitly set.
  var hasBatteryState: Bool {return self._batteryState != nil}
  /// Clears the value of `batteryState`. Subsequent reads from it will return its default value.
  mutating func clearBatteryState() {self._batteryState = nil}

  var lowPowerMode: Bool {
    get {return _lowPowerMode ?? false}
    set {_lowPowerMode = newValue}
  }
  /// Returns true if `lowPowerMode` has been explicitly set.
  var hasLowPowerMode: Bool {return self._lowPowerMode != nil}
  /// Clears the value of `lowPowerMode`. Subsequent reads from it will return its default value.
  mutating func clearLowPowerMode() {self._lowPowerMode = nil}

  var motionAndFitness: Bool {
    get {return _motionAndFitness ?? false}
    set {_motionAndFitness = newValue}
  }
  /// Returns true if `motionAndFitness` has been explicitly set.
  var hasMotionAndFitness: Bool {return self._motionAndFitness != nil}
  /// Clears the value of `motionAndFitness`. Subsequent reads from it will return its default value.
  mutating func clearMotionAndFitness() {self._motionAndFitness = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LocationAuthStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case notDetermined // = 1
    case restricted // = 2
    case denied // = 3
    case always // = 4
    case inUse // = 5

    init() {
      self = .notDetermined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .notDetermined
      case 2: self = .restricted
      case 3: self = .denied
      case 4: self = .always
      case 5: self = .inUse
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .notDetermined: return 1
      case .restricted: return 2
      case .denied: return 3
      case .always: return 4
      case .inUse: return 5
      }
    }

  }

  enum BluetoothHardware: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case off // = 1
    case on // = 2
    case resetting // = 3
    case unauthorized // = 4
    case unknown // = 5
    case unsupported // = 6

    init() {
      self = .off
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .off
      case 2: self = .on
      case 3: self = .resetting
      case 4: self = .unauthorized
      case 5: self = .unknown
      case 6: self = .unsupported
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .off: return 1
      case .on: return 2
      case .resetting: return 3
      case .unauthorized: return 4
      case .unknown: return 5
      case .unsupported: return 6
      }
    }

  }

  enum BatteryState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case notDefined // = 1
    case unplugged // = 2
    case charging // = 3
    case full // = 4

    init() {
      self = .notDefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .notDefined
      case 2: self = .unplugged
      case 3: self = .charging
      case 4: self = .full
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .notDefined: return 1
      case .unplugged: return 2
      case .charging: return 3
      case .full: return 4
      }
    }

  }

  init() {}

  fileprivate var _locationServices: Bool? = nil
  fileprivate var _locationAuthStatus: Messaging_IosCapability.LocationAuthStatus? = nil
  fileprivate var _bluetoothHardware: Messaging_IosCapability.BluetoothHardware? = nil
  fileprivate var _batteryState: Messaging_IosCapability.BatteryState? = nil
  fileprivate var _lowPowerMode: Bool? = nil
  fileprivate var _motionAndFitness: Bool? = nil
}

#if swift(>=4.2)

extension Messaging_IosCapability.LocationAuthStatus: CaseIterable {
  // Support synthesized by the compiler.
}

extension Messaging_IosCapability.BluetoothHardware: CaseIterable {
  // Support synthesized by the compiler.
}

extension Messaging_IosCapability.BatteryState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Messaging_AliasMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: String? = nil
}

struct Messaging_Battery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///as a percentage
  var battery: UInt32 {
    get {return _battery ?? 0}
    set {_battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return self._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {self._battery = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _battery: UInt32? = nil
}

struct Messaging_Acknowledgement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageIdentifier: Data {
    get {return _messageIdentifier ?? SwiftProtobuf.Internal.emptyData}
    set {_messageIdentifier = newValue}
  }
  /// Returns true if `messageIdentifier` has been explicitly set.
  var hasMessageIdentifier: Bool {return self._messageIdentifier != nil}
  /// Clears the value of `messageIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearMessageIdentifier() {self._messageIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _messageIdentifier: Data? = nil
}

struct Messaging_Step {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var angle: Double {
    get {return _angle ?? 0}
    set {_angle = newValue}
  }
  /// Returns true if `angle` has been explicitly set.
  var hasAngle: Bool {return self._angle != nil}
  /// Clears the value of `angle`. Subsequent reads from it will return its default value.
  mutating func clearAngle() {self._angle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _angle: Double? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Messaging"

extension Messaging_ServerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "globalSettings"),
    2: .same(proto: "iosSettings"),
    3: .same(proto: "androidSettings"),
    4: .same(proto: "clientKey"),
    5: .same(proto: "deviceId"),
    6: .same(proto: "sentTimestamp"),
    7: .same(proto: "messageIdentifier"),
    8: .same(proto: "stop"),
    9: .same(proto: "locationResponses"),
  ]

  fileprivate class _StorageClass {
    var _globalSettings: Messaging_GlobalSettings? = nil
    var _iosSettings: Messaging_IosSettings? = nil
    var _androidSettings: Messaging_AndroidSettings? = nil
    var _clientKey: String? = nil
    var _deviceID: Data? = nil
    var _sentTimestamp: UInt64? = nil
    var _messageIdentifier: Data? = nil
    var _stop: Messaging_ServerMessage.StopType? = nil
    var _locationResponses: [Messaging_ClientLocationResponse] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _globalSettings = source._globalSettings
      _iosSettings = source._iosSettings
      _androidSettings = source._androidSettings
      _clientKey = source._clientKey
      _deviceID = source._deviceID
      _sentTimestamp = source._sentTimestamp
      _messageIdentifier = source._messageIdentifier
      _stop = source._stop
      _locationResponses = source._locationResponses
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._globalSettings)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._iosSettings)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._androidSettings)
        case 4: try decoder.decodeSingularStringField(value: &_storage._clientKey)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._deviceID)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._sentTimestamp)
        case 7: try decoder.decodeSingularBytesField(value: &_storage._messageIdentifier)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._stop)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._locationResponses)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._globalSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._iosSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._androidSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientKey {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._deviceID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      }
      if let v = _storage._sentTimestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._messageIdentifier {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
      }
      if let v = _storage._stop {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
      }
      if !_storage._locationResponses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._locationResponses, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_ServerMessage, rhs: Messaging_ServerMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._globalSettings != rhs_storage._globalSettings {return false}
        if _storage._iosSettings != rhs_storage._iosSettings {return false}
        if _storage._androidSettings != rhs_storage._androidSettings {return false}
        if _storage._clientKey != rhs_storage._clientKey {return false}
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._sentTimestamp != rhs_storage._sentTimestamp {return false}
        if _storage._messageIdentifier != rhs_storage._messageIdentifier {return false}
        if _storage._stop != rhs_storage._stop {return false}
        if _storage._locationResponses != rhs_storage._locationResponses {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_ServerMessage.StopType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "STOP"),
    2: .same(proto: "TERMINATE"),
  ]
}

extension Messaging_IosSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IosSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "geoSettings"),
    2: .same(proto: "beaconSettings"),
    3: .same(proto: "backgroundExtension"),
    4: .same(proto: "inertialSettings"),
  ]

  fileprivate class _StorageClass {
    var _geoSettings: Messaging_IosGeoSettings? = nil
    var _beaconSettings: Messaging_IosBeaconSettings? = nil
    var _backgroundExtension: UInt64? = nil
    var _inertialSettings: Messaging_IosInertialSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _geoSettings = source._geoSettings
      _beaconSettings = source._beaconSettings
      _backgroundExtension = source._backgroundExtension
      _inertialSettings = source._inertialSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._geoSettings)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._beaconSettings)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._backgroundExtension)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._inertialSettings)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._geoSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._beaconSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._backgroundExtension {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._inertialSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_IosSettings, rhs: Messaging_IosSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._geoSettings != rhs_storage._geoSettings {return false}
        if _storage._beaconSettings != rhs_storage._beaconSettings {return false}
        if _storage._backgroundExtension != rhs_storage._backgroundExtension {return false}
        if _storage._inertialSettings != rhs_storage._inertialSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_IosBeaconSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IosBeaconSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "monitoring"),
    2: .same(proto: "foregroundRanging"),
    3: .same(proto: "backgroundRanging"),
  ]

  fileprivate class _StorageClass {
    var _monitoring: Messaging_BeaconMonitoring? = nil
    var _foregroundRanging: Messaging_BeaconRanging? = nil
    var _backgroundRanging: Messaging_BeaconRanging? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _monitoring = source._monitoring
      _foregroundRanging = source._foregroundRanging
      _backgroundRanging = source._backgroundRanging
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._monitoring)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._foregroundRanging)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._backgroundRanging)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._monitoring {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._foregroundRanging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._backgroundRanging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_IosBeaconSettings, rhs: Messaging_IosBeaconSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._monitoring != rhs_storage._monitoring {return false}
        if _storage._foregroundRanging != rhs_storage._foregroundRanging {return false}
        if _storage._backgroundRanging != rhs_storage._backgroundRanging {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_IosStandardGeoSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IosStandardGeoSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxRunTime"),
    2: .same(proto: "minOffTime"),
    3: .same(proto: "desiredAccuracy"),
    4: .same(proto: "distanceFilter"),
    5: .same(proto: "pausesUpdates"),
    6: .same(proto: "activityType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._maxRunTime)
      case 2: try decoder.decodeSingularUInt64Field(value: &self._minOffTime)
      case 3: try decoder.decodeSingularSInt32Field(value: &self._desiredAccuracy)
      case 4: try decoder.decodeSingularSInt32Field(value: &self._distanceFilter)
      case 5: try decoder.decodeSingularBoolField(value: &self._pausesUpdates)
      case 6: try decoder.decodeSingularEnumField(value: &self._activityType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._maxRunTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._minOffTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._desiredAccuracy {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._distanceFilter {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._pausesUpdates {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._activityType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_IosStandardGeoSettings, rhs: Messaging_IosStandardGeoSettings) -> Bool {
    if lhs._maxRunTime != rhs._maxRunTime {return false}
    if lhs._minOffTime != rhs._minOffTime {return false}
    if lhs._desiredAccuracy != rhs._desiredAccuracy {return false}
    if lhs._distanceFilter != rhs._distanceFilter {return false}
    if lhs._pausesUpdates != rhs._pausesUpdates {return false}
    if lhs._activityType != rhs._activityType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_IosStandardGeoSettings.Activity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OTHER"),
    1: .same(proto: "AUTO"),
    2: .same(proto: "FITNESS"),
    3: .same(proto: "NAVIGATION"),
  ]
}

extension Messaging_IosGeoSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IosGeoSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "significantUpates"),
    2: .same(proto: "foregroundGeo"),
    3: .same(proto: "backgroundGeo"),
    4: .same(proto: "iosCircularGeoFences"),
  ]

  fileprivate class _StorageClass {
    var _significantUpates: Bool? = nil
    var _foregroundGeo: Messaging_IosStandardGeoSettings? = nil
    var _backgroundGeo: Messaging_IosStandardGeoSettings? = nil
    var _iosCircularGeoFences: [Messaging_IosCircularGeoFence] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _significantUpates = source._significantUpates
      _foregroundGeo = source._foregroundGeo
      _backgroundGeo = source._backgroundGeo
      _iosCircularGeoFences = source._iosCircularGeoFences
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._significantUpates)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._foregroundGeo)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._backgroundGeo)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._iosCircularGeoFences)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._significantUpates {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      }
      if let v = _storage._foregroundGeo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._backgroundGeo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._iosCircularGeoFences.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._iosCircularGeoFences, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_IosGeoSettings, rhs: Messaging_IosGeoSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._significantUpates != rhs_storage._significantUpates {return false}
        if _storage._foregroundGeo != rhs_storage._foregroundGeo {return false}
        if _storage._backgroundGeo != rhs_storage._backgroundGeo {return false}
        if _storage._iosCircularGeoFences != rhs_storage._iosCircularGeoFences {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_IosCircularGeoFence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IosCircularGeoFence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "radius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self._latitude)
      case 2: try decoder.decodeSingularDoubleField(value: &self._longitude)
      case 3: try decoder.decodeSingularDoubleField(value: &self._radius)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    if let v = self._radius {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_IosCircularGeoFence, rhs: Messaging_IosCircularGeoFence) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._radius != rhs._radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_IosInertialSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IosInertialSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._enabled)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._interval)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._interval {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_IosInertialSettings, rhs: Messaging_IosInertialSettings) -> Bool {
    if lhs._enabled != rhs._enabled {return false}
    if lhs._interval != rhs._interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_AndroidSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AndroidSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "geoSettings"),
    2: .same(proto: "beaconSettings"),
    3: .same(proto: "wifiSettings"),
    4: .same(proto: "foregroundService"),
    5: .same(proto: "inertialSettings"),
  ]

  fileprivate class _StorageClass {
    var _geoSettings: Messaging_AndroidGeoSettings? = nil
    var _beaconSettings: Messaging_AndroidBeaconSettings? = nil
    var _wifiSettings: Messaging_AndroidWifiSettings? = nil
    var _foregroundService: Bool? = nil
    var _inertialSettings: Messaging_AndroidInertialSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _geoSettings = source._geoSettings
      _beaconSettings = source._beaconSettings
      _wifiSettings = source._wifiSettings
      _foregroundService = source._foregroundService
      _inertialSettings = source._inertialSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._geoSettings)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._beaconSettings)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._wifiSettings)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._foregroundService)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._inertialSettings)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._geoSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._beaconSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._wifiSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._foregroundService {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._inertialSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_AndroidSettings, rhs: Messaging_AndroidSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._geoSettings != rhs_storage._geoSettings {return false}
        if _storage._beaconSettings != rhs_storage._beaconSettings {return false}
        if _storage._wifiSettings != rhs_storage._wifiSettings {return false}
        if _storage._foregroundService != rhs_storage._foregroundService {return false}
        if _storage._inertialSettings != rhs_storage._inertialSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_AndroidGeoSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AndroidGeoSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minDistance"),
    2: .same(proto: "minTime"),
    3: .same(proto: "priority"),
    4: .same(proto: "batchTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._minDistance)
      case 2: try decoder.decodeSingularUInt64Field(value: &self._minTime)
      case 3: try decoder.decodeSingularEnumField(value: &self._priority)
      case 4: try decoder.decodeSingularUInt64Field(value: &self._batchTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._minDistance {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._minTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._priority {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._batchTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_AndroidGeoSettings, rhs: Messaging_AndroidGeoSettings) -> Bool {
    if lhs._minDistance != rhs._minDistance {return false}
    if lhs._minTime != rhs._minTime {return false}
    if lhs._priority != rhs._priority {return false}
    if lhs._batchTime != rhs._batchTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_AndroidGeoSettings.Priority: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HIGH_ACCURACY"),
    1: .same(proto: "BALANCED_POWER_ACCURACY"),
    2: .same(proto: "LOW_POWER"),
    3: .same(proto: "NO_POWER"),
  ]
}

extension Messaging_AndroidBeaconSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AndroidBeaconSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "advertisements"),
    3: .same(proto: "ranging"),
  ]

  fileprivate class _StorageClass {
    var _advertisements: [Messaging_BeaconAdvertisement] = []
    var _ranging: Messaging_BeaconRanging? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _advertisements = source._advertisements
      _ranging = source._ranging
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._advertisements)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._ranging)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._advertisements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._advertisements, fieldNumber: 1)
      }
      if let v = _storage._ranging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_AndroidBeaconSettings, rhs: Messaging_AndroidBeaconSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._advertisements != rhs_storage._advertisements {return false}
        if _storage._ranging != rhs_storage._ranging {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_AndroidWifiSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AndroidWifiSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "interval"),
    3: .same(proto: "state"),
    4: .same(proto: "rttEnabled"),
    5: .same(proto: "rttInterval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._enabled)
      case 2: try decoder.decodeSingularUInt64Field(value: &self._interval)
      case 3: try decoder.decodeSingularStringField(value: &self._state)
      case 4: try decoder.decodeSingularBoolField(value: &self._rttEnabled)
      case 5: try decoder.decodeSingularUInt64Field(value: &self._rttInterval)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._interval {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._state {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._rttEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._rttInterval {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_AndroidWifiSettings, rhs: Messaging_AndroidWifiSettings) -> Bool {
    if lhs._enabled != rhs._enabled {return false}
    if lhs._interval != rhs._interval {return false}
    if lhs._state != rhs._state {return false}
    if lhs._rttEnabled != rhs._rttEnabled {return false}
    if lhs._rttInterval != rhs._rttInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_BeaconRegion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeaconRegion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UUID"),
    2: .same(proto: "major"),
    3: .same(proto: "minor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._uuid)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._major)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._minor)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._major {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._minor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_BeaconRegion, rhs: Messaging_BeaconRegion) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs._major != rhs._major {return false}
    if lhs._minor != rhs._minor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_BeaconAdvertisement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeaconAdvertisement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "frequency"),
    3: .same(proto: "power"),
    4: .same(proto: "onPeriod"),
    5: .same(proto: "offPeriod"),
    6: .same(proto: "startTime"),
    7: .same(proto: "repeat"),
    8: .same(proto: "eid"),
  ]

  fileprivate class _StorageClass {
    var _identifier: Messaging_BeaconRegion? = nil
    var _frequency: Messaging_BeaconAdvertisement.Frequency? = nil
    var _power: Messaging_BeaconAdvertisement.Power? = nil
    var _onPeriod: UInt64? = nil
    var _offPeriod: UInt64? = nil
    var _startTime: UInt64? = nil
    var _repeat: Bool? = nil
    var _eid: Messaging_EID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identifier = source._identifier
      _frequency = source._frequency
      _power = source._power
      _onPeriod = source._onPeriod
      _offPeriod = source._offPeriod
      _startTime = source._startTime
      _repeat = source._repeat
      _eid = source._eid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._identifier)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._frequency)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._power)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._onPeriod)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._offPeriod)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._startTime)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._repeat)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._eid)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._identifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._frequency {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._power {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      }
      if let v = _storage._onPeriod {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._offPeriod {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._repeat {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
      if let v = _storage._eid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_BeaconAdvertisement, rhs: Messaging_BeaconAdvertisement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identifier != rhs_storage._identifier {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._power != rhs_storage._power {return false}
        if _storage._onPeriod != rhs_storage._onPeriod {return false}
        if _storage._offPeriod != rhs_storage._offPeriod {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._repeat != rhs_storage._repeat {return false}
        if _storage._eid != rhs_storage._eid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_BeaconAdvertisement.Frequency: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOW_FREQUENCY"),
    1: .same(proto: "BALANCED_FREQUENCY"),
    2: .same(proto: "HIGH_FREQUENCY"),
  ]
}

extension Messaging_BeaconAdvertisement.Power: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ULTRALOW_POWER"),
    1: .same(proto: "LOW_POWER"),
    2: .same(proto: "MEDIUM_POWER"),
    3: .same(proto: "HIGH_POWER"),
  ]
}

extension Messaging_EID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "secret"),
    2: .same(proto: "k"),
    3: .same(proto: "clockOffset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._secret)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._k)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._clockOffset)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._secret {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._k {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._clockOffset {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_EID, rhs: Messaging_EID) -> Bool {
    if lhs._secret != rhs._secret {return false}
    if lhs._k != rhs._k {return false}
    if lhs._clockOffset != rhs._clockOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_BeaconMonitoring: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeaconMonitoring"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "regions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.regions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.regions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_BeaconMonitoring, rhs: Messaging_BeaconMonitoring) -> Bool {
    if lhs.regions != rhs.regions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_BeaconRanging: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeaconRanging"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxRunTime"),
    2: .same(proto: "minOffTime"),
    3: .same(proto: "regions"),
    4: .same(proto: "filter"),
    5: .same(proto: "nonBeaconScan"),
    6: .same(proto: "eddystoneScan"),
    7: .same(proto: "iBeaconScan"),
  ]

  fileprivate class _StorageClass {
    var _maxRunTime: UInt64? = nil
    var _minOffTime: UInt64? = nil
    var _regions: [Messaging_BeaconRegion] = []
    var _filter: Messaging_BeaconFilter? = nil
    var _nonBeaconScan: Bool? = nil
    var _eddystoneScan: Bool? = nil
    var _iBeaconScan: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _maxRunTime = source._maxRunTime
      _minOffTime = source._minOffTime
      _regions = source._regions
      _filter = source._filter
      _nonBeaconScan = source._nonBeaconScan
      _eddystoneScan = source._eddystoneScan
      _iBeaconScan = source._iBeaconScan
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._maxRunTime)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._minOffTime)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._regions)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._filter)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._nonBeaconScan)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._eddystoneScan)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._iBeaconScan)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._maxRunTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._minOffTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if !_storage._regions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._regions, fieldNumber: 3)
      }
      if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._nonBeaconScan {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      }
      if let v = _storage._eddystoneScan {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if let v = _storage._iBeaconScan {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_BeaconRanging, rhs: Messaging_BeaconRanging) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._maxRunTime != rhs_storage._maxRunTime {return false}
        if _storage._minOffTime != rhs_storage._minOffTime {return false}
        if _storage._regions != rhs_storage._regions {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._nonBeaconScan != rhs_storage._nonBeaconScan {return false}
        if _storage._eddystoneScan != rhs_storage._eddystoneScan {return false}
        if _storage._iBeaconScan != rhs_storage._iBeaconScan {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_BeaconFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeaconFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "windowSize"),
    2: .same(proto: "maxObservations"),
    3: .same(proto: "excludeRegions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._windowSize)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._maxObservations)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.excludeRegions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._windowSize {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._maxObservations {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if !self.excludeRegions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludeRegions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_BeaconFilter, rhs: Messaging_BeaconFilter) -> Bool {
    if lhs._windowSize != rhs._windowSize {return false}
    if lhs._maxObservations != rhs._maxObservations {return false}
    if lhs.excludeRegions != rhs.excludeRegions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_AndroidInertialSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AndroidInertialSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "frequency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._enabled)
      case 2: try decoder.decodeSingularEnumField(value: &self._frequency)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._frequency {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_AndroidInertialSettings, rhs: Messaging_AndroidInertialSettings) -> Bool {
    if lhs._enabled != rhs._enabled {return false}
    if lhs._frequency != rhs._frequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_AndroidInertialSettings.Frequency: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FASTEST"),
    2: .same(proto: "GAME"),
    3: .same(proto: "UI"),
    4: .same(proto: "NORMAL"),
  ]
}

extension Messaging_GlobalSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlobalSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "radioSilence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._id)
      case 3: try decoder.decodeSingularUInt64Field(value: &self._radioSilence)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._radioSilence {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_GlobalSettings, rhs: Messaging_GlobalSettings) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._radioSilence != rhs._radioSilence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_ClientLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientLocationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_ClientLocationRequest, rhs: Messaging_ClientLocationRequest) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_ClientLocationRequest.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SINGLE"),
    2: .same(proto: "ONGOING"),
    3: .same(proto: "STOP"),
  ]
}

extension Messaging_ClientLocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientLocationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "error"),
    4: .same(proto: "headingOffset"),
    5: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self._latitude)
      case 2: try decoder.decodeSingularDoubleField(value: &self._longitude)
      case 3: try decoder.decodeSingularDoubleField(value: &self._error)
      case 4: try decoder.decodeSingularDoubleField(value: &self._headingOffset)
      case 5: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    if let v = self._error {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    if let v = self._headingOffset {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_ClientLocationResponse, rhs: Messaging_ClientLocationResponse) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._error != rhs._error {return false}
    if lhs._headingOffset != rhs._headingOffset {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_ClientMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locationMessage"),
    2: .same(proto: "bluetoothMessage"),
    3: .same(proto: "ibeaconMessage"),
    4: .same(proto: "wifiMessage"),
    5: .same(proto: "marker"),
    6: .same(proto: "alias"),
    7: .same(proto: "capability"),
    8: .same(proto: "battery"),
    9: .same(proto: "clientKey"),
    10: .same(proto: "deviceId"),
    11: .same(proto: "receivedTimestamp"),
    12: .same(proto: "sentTime"),
    13: .same(proto: "iosCapability"),
    14: .same(proto: "messageIdentifier"),
    15: .same(proto: "userInputLocationMessage"),
    16: .same(proto: "surveryMode"),
    17: .same(proto: "wifiRttMessage"),
    18: .same(proto: "eddystonemessage"),
    19: .same(proto: "step"),
    20: .same(proto: "locationRequest"),
    21: .same(proto: "circularGeoFenceEvents"),
  ]

  fileprivate class _StorageClass {
    var _locationMessage: [Messaging_LocationMessage] = []
    var _bluetoothMessage: [Messaging_Bluetooth] = []
    var _ibeaconMessage: [Messaging_IBeacon] = []
    var _wifiMessage: [Messaging_WifiMessage] = []
    var _marker: Messaging_MarkerMessage? = nil
    var _alias: [Messaging_AliasMessage] = []
    var _capability: Messaging_Capability? = nil
    var _battery: Messaging_Battery? = nil
    var _clientKey: String? = nil
    var _deviceID: Data? = nil
    var _receivedTimestamp: UInt64? = nil
    var _sentTime: UInt64? = nil
    var _iosCapability: Messaging_IosCapability? = nil
    var _messageIdentifier: Data? = nil
    var _userInputLocationMessage: [Messaging_UserInputLocationMessage] = []
    var _surveryMode: Bool? = nil
    var _wifiRttMessage: [Messaging_WifiRTTMessage] = []
    var _eddystonemessage: [Messaging_EddystoneBeacon] = []
    var _step: [Messaging_Step] = []
    var _locationRequest: Messaging_ClientLocationRequest? = nil
    var _circularGeoFenceEvents: [Messaging_CircularGeoFenceEvent] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _locationMessage = source._locationMessage
      _bluetoothMessage = source._bluetoothMessage
      _ibeaconMessage = source._ibeaconMessage
      _wifiMessage = source._wifiMessage
      _marker = source._marker
      _alias = source._alias
      _capability = source._capability
      _battery = source._battery
      _clientKey = source._clientKey
      _deviceID = source._deviceID
      _receivedTimestamp = source._receivedTimestamp
      _sentTime = source._sentTime
      _iosCapability = source._iosCapability
      _messageIdentifier = source._messageIdentifier
      _userInputLocationMessage = source._userInputLocationMessage
      _surveryMode = source._surveryMode
      _wifiRttMessage = source._wifiRttMessage
      _eddystonemessage = source._eddystonemessage
      _step = source._step
      _locationRequest = source._locationRequest
      _circularGeoFenceEvents = source._circularGeoFenceEvents
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._locationMessage)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._bluetoothMessage)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._ibeaconMessage)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._wifiMessage)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._marker)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._alias)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._capability)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._battery)
        case 9: try decoder.decodeSingularStringField(value: &_storage._clientKey)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._deviceID)
        case 11: try decoder.decodeSingularUInt64Field(value: &_storage._receivedTimestamp)
        case 12: try decoder.decodeSingularUInt64Field(value: &_storage._sentTime)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._iosCapability)
        case 14: try decoder.decodeSingularBytesField(value: &_storage._messageIdentifier)
        case 15: try decoder.decodeRepeatedMessageField(value: &_storage._userInputLocationMessage)
        case 16: try decoder.decodeSingularBoolField(value: &_storage._surveryMode)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._wifiRttMessage)
        case 18: try decoder.decodeRepeatedMessageField(value: &_storage._eddystonemessage)
        case 19: try decoder.decodeRepeatedMessageField(value: &_storage._step)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._locationRequest)
        case 21: try decoder.decodeRepeatedMessageField(value: &_storage._circularGeoFenceEvents)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._locationMessage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._locationMessage, fieldNumber: 1)
      }
      if !_storage._bluetoothMessage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bluetoothMessage, fieldNumber: 2)
      }
      if !_storage._ibeaconMessage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ibeaconMessage, fieldNumber: 3)
      }
      if !_storage._wifiMessage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._wifiMessage, fieldNumber: 4)
      }
      if let v = _storage._marker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._alias.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._alias, fieldNumber: 6)
      }
      if let v = _storage._capability {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._battery {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._clientKey {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._deviceID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      }
      if let v = _storage._receivedTimestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._sentTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
      }
      if let v = _storage._iosCapability {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._messageIdentifier {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 14)
      }
      if !_storage._userInputLocationMessage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userInputLocationMessage, fieldNumber: 15)
      }
      if let v = _storage._surveryMode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if !_storage._wifiRttMessage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._wifiRttMessage, fieldNumber: 17)
      }
      if !_storage._eddystonemessage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._eddystonemessage, fieldNumber: 18)
      }
      if !_storage._step.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._step, fieldNumber: 19)
      }
      if let v = _storage._locationRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if !_storage._circularGeoFenceEvents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._circularGeoFenceEvents, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_ClientMessage, rhs: Messaging_ClientMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._locationMessage != rhs_storage._locationMessage {return false}
        if _storage._bluetoothMessage != rhs_storage._bluetoothMessage {return false}
        if _storage._ibeaconMessage != rhs_storage._ibeaconMessage {return false}
        if _storage._wifiMessage != rhs_storage._wifiMessage {return false}
        if _storage._marker != rhs_storage._marker {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._capability != rhs_storage._capability {return false}
        if _storage._battery != rhs_storage._battery {return false}
        if _storage._clientKey != rhs_storage._clientKey {return false}
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._receivedTimestamp != rhs_storage._receivedTimestamp {return false}
        if _storage._sentTime != rhs_storage._sentTime {return false}
        if _storage._iosCapability != rhs_storage._iosCapability {return false}
        if _storage._messageIdentifier != rhs_storage._messageIdentifier {return false}
        if _storage._userInputLocationMessage != rhs_storage._userInputLocationMessage {return false}
        if _storage._surveryMode != rhs_storage._surveryMode {return false}
        if _storage._wifiRttMessage != rhs_storage._wifiRttMessage {return false}
        if _storage._eddystonemessage != rhs_storage._eddystonemessage {return false}
        if _storage._step != rhs_storage._step {return false}
        if _storage._locationRequest != rhs_storage._locationRequest {return false}
        if _storage._circularGeoFenceEvents != rhs_storage._circularGeoFenceEvents {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_CircularGeoFenceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CircularGeoFenceEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "radius"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self._latitude)
      case 2: try decoder.decodeSingularDoubleField(value: &self._longitude)
      case 3: try decoder.decodeSingularDoubleField(value: &self._radius)
      case 4: try decoder.decodeSingularEnumField(value: &self._type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    if let v = self._radius {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_CircularGeoFenceEvent, rhs: Messaging_CircularGeoFenceEvent) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._radius != rhs._radius {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_CircularGeoFenceEvent.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ENTRY"),
    2: .same(proto: "EXIT"),
  ]
}

extension Messaging_UserInputLocationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserInputLocationMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "altitude"),
    4: .same(proto: "x"),
    5: .same(proto: "y"),
    6: .same(proto: "z"),
    7: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self._latitude)
      case 2: try decoder.decodeSingularDoubleField(value: &self._longitude)
      case 3: try decoder.decodeSingularDoubleField(value: &self._altitude)
      case 4: try decoder.decodeSingularDoubleField(value: &self._x)
      case 5: try decoder.decodeSingularDoubleField(value: &self._y)
      case 6: try decoder.decodeSingularDoubleField(value: &self._z)
      case 7: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    if let v = self._altitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    if let v = self._x {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }
    if let v = self._y {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }
    if let v = self._z {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_UserInputLocationMessage, rhs: Messaging_UserInputLocationMessage) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._altitude != rhs._altitude {return false}
    if lhs._x != rhs._x {return false}
    if lhs._y != rhs._y {return false}
    if lhs._z != rhs._z {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_LocationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocationMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    5: .same(proto: "altitude"),
    3: .same(proto: "horizontalAccuracy"),
    6: .same(proto: "verticalAccuracy"),
    7: .same(proto: "course"),
    8: .same(proto: "speed"),
    4: .same(proto: "timestamp"),
    9: .same(proto: "isMockLocation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self._latitude)
      case 2: try decoder.decodeSingularDoubleField(value: &self._longitude)
      case 3: try decoder.decodeSingularDoubleField(value: &self._horizontalAccuracy)
      case 4: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      case 5: try decoder.decodeSingularDoubleField(value: &self._altitude)
      case 6: try decoder.decodeSingularDoubleField(value: &self._verticalAccuracy)
      case 7: try decoder.decodeSingularDoubleField(value: &self._course)
      case 8: try decoder.decodeSingularDoubleField(value: &self._speed)
      case 9: try decoder.decodeSingularBoolField(value: &self._isMockLocation)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    if let v = self._horizontalAccuracy {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._altitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }
    if let v = self._verticalAccuracy {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }
    if let v = self._course {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
    }
    if let v = self._speed {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 8)
    }
    if let v = self._isMockLocation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_LocationMessage, rhs: Messaging_LocationMessage) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._altitude != rhs._altitude {return false}
    if lhs._horizontalAccuracy != rhs._horizontalAccuracy {return false}
    if lhs._verticalAccuracy != rhs._verticalAccuracy {return false}
    if lhs._course != rhs._course {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._isMockLocation != rhs._isMockLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_Bluetooth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bluetooth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    5: .same(proto: "mac"),
    2: .same(proto: "rssi"),
    3: .same(proto: "tx"),
    4: .same(proto: "timestamp"),
    8: .same(proto: "averagingWindow"),
    6: .same(proto: "amountAveraged"),
    7: .same(proto: "scanData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._identifier)
      case 2: try decoder.decodeSingularSInt32Field(value: &self._rssi)
      case 3: try decoder.decodeSingularSInt32Field(value: &self._tx)
      case 4: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      case 5: try decoder.decodeSingularBytesField(value: &self._mac)
      case 6: try decoder.decodeSingularUInt32Field(value: &self._amountAveraged)
      case 7: try decoder.decodeRepeatedBytesField(value: &self.scanData)
      case 8: try decoder.decodeSingularUInt32Field(value: &self._averagingWindow)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._identifier {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._rssi {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._tx {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._mac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    if let v = self._amountAveraged {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if !self.scanData.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.scanData, fieldNumber: 7)
    }
    if let v = self._averagingWindow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_Bluetooth, rhs: Messaging_Bluetooth) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._mac != rhs._mac {return false}
    if lhs._rssi != rhs._rssi {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._averagingWindow != rhs._averagingWindow {return false}
    if lhs._amountAveraged != rhs._amountAveraged {return false}
    if lhs.scanData != rhs.scanData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_IBeacon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IBeacon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "major"),
    3: .same(proto: "minor"),
    4: .same(proto: "rssi"),
    5: .same(proto: "proximity"),
    6: .same(proto: "accuracy"),
    7: .same(proto: "timestamp"),
    8: .same(proto: "averagingWindow"),
    9: .same(proto: "amountAveraged"),
    10: .same(proto: "batteryLevel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._uuid)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._major)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._minor)
      case 4: try decoder.decodeSingularSInt32Field(value: &self._rssi)
      case 5: try decoder.decodeSingularUInt32Field(value: &self._proximity)
      case 6: try decoder.decodeSingularDoubleField(value: &self._accuracy)
      case 7: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      case 8: try decoder.decodeSingularUInt64Field(value: &self._averagingWindow)
      case 9: try decoder.decodeSingularUInt32Field(value: &self._amountAveraged)
      case 10: try decoder.decodeSingularUInt32Field(value: &self._batteryLevel)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._major {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._minor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._rssi {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._proximity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._accuracy {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    }
    if let v = self._averagingWindow {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    }
    if let v = self._amountAveraged {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._batteryLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_IBeacon, rhs: Messaging_IBeacon) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs._major != rhs._major {return false}
    if lhs._minor != rhs._minor {return false}
    if lhs._rssi != rhs._rssi {return false}
    if lhs._proximity != rhs._proximity {return false}
    if lhs._accuracy != rhs._accuracy {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._averagingWindow != rhs._averagingWindow {return false}
    if lhs._amountAveraged != rhs._amountAveraged {return false}
    if lhs._batteryLevel != rhs._batteryLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_EddystoneBeacon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EddystoneBeacon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eid"),
    2: .same(proto: "mac"),
    3: .same(proto: "tx"),
    4: .same(proto: "rssi"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "averagingWindow"),
    7: .same(proto: "amountAveraged"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._eid)
      case 2: try decoder.decodeSingularBytesField(value: &self._mac)
      case 3: try decoder.decodeSingularSInt32Field(value: &self._tx)
      case 4: try decoder.decodeSingularSInt32Field(value: &self._rssi)
      case 5: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      case 6: try decoder.decodeSingularUInt64Field(value: &self._averagingWindow)
      case 7: try decoder.decodeSingularUInt32Field(value: &self._amountAveraged)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._mac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._tx {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._rssi {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._averagingWindow {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }
    if let v = self._amountAveraged {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_EddystoneBeacon, rhs: Messaging_EddystoneBeacon) -> Bool {
    if lhs._eid != rhs._eid {return false}
    if lhs._mac != rhs._mac {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs._rssi != rhs._rssi {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._averagingWindow != rhs._averagingWindow {return false}
    if lhs._amountAveraged != rhs._amountAveraged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_WifiMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bssid"),
    2: .same(proto: "ssid"),
    3: .same(proto: "rssi"),
    4: .same(proto: "frequency"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "centerFreq0"),
    7: .same(proto: "centerFreq1"),
    8: .same(proto: "channelWidth"),
    9: .same(proto: "rttResponder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._bssid)
      case 2: try decoder.decodeSingularStringField(value: &self._ssid)
      case 3: try decoder.decodeSingularSInt32Field(value: &self._rssi)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._frequency)
      case 5: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      case 6: try decoder.decodeSingularUInt32Field(value: &self._centerFreq0)
      case 7: try decoder.decodeSingularUInt32Field(value: &self._centerFreq1)
      case 8: try decoder.decodeSingularEnumField(value: &self._channelWidth)
      case 9: try decoder.decodeSingularBoolField(value: &self._rttResponder)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bssid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._ssid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._rssi {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._frequency {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._centerFreq0 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._centerFreq1 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._channelWidth {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    }
    if let v = self._rttResponder {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_WifiMessage, rhs: Messaging_WifiMessage) -> Bool {
    if lhs._bssid != rhs._bssid {return false}
    if lhs._ssid != rhs._ssid {return false}
    if lhs._rssi != rhs._rssi {return false}
    if lhs._frequency != rhs._frequency {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._centerFreq0 != rhs._centerFreq0 {return false}
    if lhs._centerFreq1 != rhs._centerFreq1 {return false}
    if lhs._channelWidth != rhs._channelWidth {return false}
    if lhs._rttResponder != rhs._rttResponder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_WifiMessage.ChannelWidth: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CHANNEL_WIDTH_160MHZ"),
    2: .same(proto: "CHANNEL_WIDTH_20MHZ"),
    3: .same(proto: "CHANNEL_WIDTH_40MHZ"),
    4: .same(proto: "CHANNEL_WIDTH_80MHZ"),
    5: .same(proto: "CHANNEL_WIDTH_80MHZ_PLUS_MHZ"),
  ]
}

extension Messaging_WifiRTTMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiRTTMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accessPoint"),
    2: .same(proto: "distance"),
    3: .same(proto: "distanceStdDev"),
    4: .same(proto: "attemptedMeasurements"),
    5: .same(proto: "successfulMeasurements"),
  ]

  fileprivate class _StorageClass {
    var _accessPoint: Messaging_WifiMessage? = nil
    var _distance: Int32? = nil
    var _distanceStdDev: Int32? = nil
    var _attemptedMeasurements: UInt32? = nil
    var _successfulMeasurements: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accessPoint = source._accessPoint
      _distance = source._distance
      _distanceStdDev = source._distanceStdDev
      _attemptedMeasurements = source._attemptedMeasurements
      _successfulMeasurements = source._successfulMeasurements
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accessPoint)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._distance)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._distanceStdDev)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._attemptedMeasurements)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._successfulMeasurements)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accessPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._distance {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._distanceStdDev {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._attemptedMeasurements {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._successfulMeasurements {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_WifiRTTMessage, rhs: Messaging_WifiRTTMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accessPoint != rhs_storage._accessPoint {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._distanceStdDev != rhs_storage._distanceStdDev {return false}
        if _storage._attemptedMeasurements != rhs_storage._attemptedMeasurements {return false}
        if _storage._successfulMeasurements != rhs_storage._successfulMeasurements {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_MarkerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarkerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._data)
      case 2: try decoder.decodeSingularUInt64Field(value: &self._time)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._time {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_MarkerMessage, rhs: Messaging_MarkerMessage) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_Capability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capability"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasBle"),
    2: .same(proto: "canAdvertise"),
    3: .same(proto: "isBTOn"),
    4: .same(proto: "hasLocationPermission"),
    5: .same(proto: "isGPSOn"),
    6: .same(proto: "foregroundService"),
    7: .same(proto: "expiryTime"),
    8: .same(proto: "rtt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._hasBle_p)
      case 2: try decoder.decodeSingularBoolField(value: &self._canAdvertise)
      case 3: try decoder.decodeSingularBoolField(value: &self._isBton)
      case 4: try decoder.decodeSingularBoolField(value: &self._hasLocationPermission_p)
      case 5: try decoder.decodeSingularBoolField(value: &self._isGpson)
      case 6: try decoder.decodeSingularBoolField(value: &self._foregroundService)
      case 7: try decoder.decodeSingularUInt64Field(value: &self._expiryTime)
      case 8: try decoder.decodeSingularBoolField(value: &self._rtt)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._hasBle_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._canAdvertise {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._isBton {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._hasLocationPermission_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._isGpson {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._foregroundService {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if let v = self._expiryTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    }
    if let v = self._rtt {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_Capability, rhs: Messaging_Capability) -> Bool {
    if lhs._hasBle_p != rhs._hasBle_p {return false}
    if lhs._canAdvertise != rhs._canAdvertise {return false}
    if lhs._isBton != rhs._isBton {return false}
    if lhs._hasLocationPermission_p != rhs._hasLocationPermission_p {return false}
    if lhs._isGpson != rhs._isGpson {return false}
    if lhs._foregroundService != rhs._foregroundService {return false}
    if lhs._expiryTime != rhs._expiryTime {return false}
    if lhs._rtt != rhs._rtt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_IosCapability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IosCapability"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locationServices"),
    2: .same(proto: "locationAuthStatus"),
    3: .same(proto: "bluetoothHardware"),
    4: .same(proto: "batteryState"),
    5: .same(proto: "lowPowerMode"),
    6: .same(proto: "motionAndFitness"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._locationServices)
      case 2: try decoder.decodeSingularEnumField(value: &self._locationAuthStatus)
      case 3: try decoder.decodeSingularEnumField(value: &self._bluetoothHardware)
      case 4: try decoder.decodeSingularEnumField(value: &self._batteryState)
      case 5: try decoder.decodeSingularBoolField(value: &self._lowPowerMode)
      case 6: try decoder.decodeSingularBoolField(value: &self._motionAndFitness)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locationServices {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._locationAuthStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._bluetoothHardware {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._batteryState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if let v = self._lowPowerMode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._motionAndFitness {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_IosCapability, rhs: Messaging_IosCapability) -> Bool {
    if lhs._locationServices != rhs._locationServices {return false}
    if lhs._locationAuthStatus != rhs._locationAuthStatus {return false}
    if lhs._bluetoothHardware != rhs._bluetoothHardware {return false}
    if lhs._batteryState != rhs._batteryState {return false}
    if lhs._lowPowerMode != rhs._lowPowerMode {return false}
    if lhs._motionAndFitness != rhs._motionAndFitness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_IosCapability.LocationAuthStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NOT_DETERMINED"),
    2: .same(proto: "RESTRICTED"),
    3: .same(proto: "DENIED"),
    4: .same(proto: "ALWAYS"),
    5: .same(proto: "IN_USE"),
  ]
}

extension Messaging_IosCapability.BluetoothHardware: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OFF"),
    2: .same(proto: "ON"),
    3: .same(proto: "RESETTING"),
    4: .same(proto: "UNAUTHORIZED"),
    5: .same(proto: "UNKNOWN"),
    6: .same(proto: "UNSUPPORTED"),
  ]
}

extension Messaging_IosCapability.BatteryState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NOT_DEFINED"),
    2: .same(proto: "UNPLUGGED"),
    3: .same(proto: "CHARGING"),
    4: .same(proto: "FULL"),
  ]
}

extension Messaging_AliasMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AliasMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._key)
      case 2: try decoder.decodeSingularStringField(value: &self._value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_AliasMessage, rhs: Messaging_AliasMessage) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_Battery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Battery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "battery"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._battery)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._battery {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_Battery, rhs: Messaging_Battery) -> Bool {
    if lhs._battery != rhs._battery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_Acknowledgement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Acknowledgement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageIdentifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._messageIdentifier)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._messageIdentifier {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_Acknowledgement, rhs: Messaging_Acknowledgement) -> Bool {
    if lhs._messageIdentifier != rhs._messageIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messaging_Step: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Step"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "angle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      case 2: try decoder.decodeSingularDoubleField(value: &self._angle)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._angle {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messaging_Step, rhs: Messaging_Step) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._angle != rhs._angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
